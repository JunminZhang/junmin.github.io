<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql索引</title>
    <url>/2019/12/03/Mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p><img src="http://qiniupic.xiaomintongxue.cn/img/20191203041651331.png" alt="20191203041651331"></p>
<p><img src="http://qiniupic.xiaomintongxue.cn/img/image-20201209165757503.png" alt="image-20201209165757503" style="zoom: 33%;"></p>
<h4 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h4><p>123123<br><img src="/Mysql索引/20201209051413880.png" alt></p>
<h4 id="多路平衡查找树B-Tree"><a href="#多路平衡查找树B-Tree" class="headerlink" title="多路平衡查找树B-Tree"></a>多路平衡查找树B-Tree</h4><p><img src="/Mysql索引/20191203041743846.png" alt></p>
<h4 id="Mysql的B-Tree"><a href="#Mysql的B-Tree" class="headerlink" title="Mysql的B+Tree"></a>Mysql的B+Tree</h4><p><img src="/Mysql索引/20191203041753272.png" alt></p>
 <a id="more"></a>
<h4 id="B-Tree和B-Tree的区别"><a href="#B-Tree和B-Tree的区别" class="headerlink" title="B-Tree和B+Tree的区别"></a>B-Tree和B+Tree的区别</h4><p>1 ，B+ 节点关键字搜索采用闭合区间<br>2 ，B+ 非叶节点不保存数据相关信息，只保存关键字和子节点的引用<br>3 ，B+ 关键字对应的数据保存在叶子节点中<br>4 ，B+ 叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系</p>
<h5 id="为什么使用B-Tree"><a href="#为什么使用B-Tree" class="headerlink" title="为什么使用B+Tree"></a>为什么使用B+Tree</h5><p>B+ 树是B- 树的变种（PLUS 版）多路绝对平衡查找树，他拥有B- 树的优势<br>B+ 树扫库、表能力更强<br>B+ 树的磁盘读写能力更 强<br>B+树 树 的排序能力更强<br>B+ 树的查询效率更加 稳定（仁者见仁、智者见智）</p>
<h5 id="为什么不使用二叉树"><a href="#为什么不使用二叉树" class="headerlink" title="为什么不使用二叉树"></a>为什么不使用二叉树</h5><ul>
<li>它太深了<br>数据处的（高）深度决定着他的IO 操作次数，IO 操作耗时大</li>
<li>它太小了<br>每一个磁盘块 （节点/ 页） 保存的数据量太小 了没有很好的利用操作磁盘IO 的数据 交换 特性，也没有利用好磁盘IO 的预 读能力（空间局部性原理 ），从而带来频繁的IO。</li>
</ul>
<h3 id="Innodb与Myisam的区别"><a href="#Innodb与Myisam的区别" class="headerlink" title="Innodb与Myisam的区别"></a>Innodb与Myisam的区别</h3><p><img src="/Mysql索引/20191203041837918.png" alt></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引由插件式引擎实现<br>索引是为了加速对表中数据行的检索而创建的一种数据结构<br><img src="/Mysql索引/20191203041855104.png" alt></p>
<h3 id="Mysql-B-Tree索引体现形式"><a href="#Mysql-B-Tree索引体现形式" class="headerlink" title="Mysql B+Tree索引体现形式"></a>Mysql B+Tree索引体现形式</h3><h4 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h4><p><img src="/Mysql索引/20191203041921144.png" alt></p>
<p><img src="/Mysql索引/20191203041934879.png" alt></p>
<h4 id="Myisam"><a href="#Myisam" class="headerlink" title="Myisam"></a>Myisam</h4><p><img src="/Mysql索引/20191203041946821.png" alt></p>
<p><img src="/Mysql索引/20191203041954647.png" alt></p>
<h3 id="索引知识补充"><a href="#索引知识补充" class="headerlink" title="索引知识补充"></a>索引知识补充</h3><h4 id="列的离散性"><a href="#列的离散性" class="headerlink" title="列的离散性"></a>列的离散性</h4><p><img src="/Mysql索引/20191203042009126.png" alt></p>
<ul>
<li>列的离散性越低，被转为全表扫描的可能性越高<h4 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h4><img src="/Mysql索引/20191203042015880.png" alt></li>
<li>根据创建表时指定的排序规则依次从左到右进行比对<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><img src="/Mysql索引/20191203042022422.png" alt><h4 id="冗余索引"><a href="#冗余索引" class="headerlink" title="冗余索引"></a>冗余索引</h4><img src="/Mysql索引/20191203042033961.png" alt><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><img src="/Mysql索引/20191203042043411.png" alt></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>索引列的数据长度能少则少。</li>
<li>索引一定不是越多越好，越全越好，一定是建合适的。</li>
<li>匹配列前缀可用到索引 like 9999%（列的离散型高的情况下），like %9999%、like %9999用不到索引；</li>
<li>Where 条件中 not in 和 &lt;&gt;操作无法使用索引；</li>
<li>匹配范围值，order by 也可用到索引；</li>
<li>多用指定列查询，只返回自己想到的数据列，少用select * ；</li>
<li>联合索引中如果不是按照索引·最左列开始查找，无法使用索引；</li>
<li>联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引；</li>
<li>联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引；</li>
<li>在创建索引时尽量使用不能为null的列</li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>作为索引字段在定义长度时尽量越短越好<br>字段长度越少，底层数据的路数越多，效率越高</li>
</ul>
]]></content>
      <categories>
        <category>数据库 mysql</category>
      </categories>
      <tags>
        <tag>数据库 mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Threadlocal实现原理</title>
    <url>/2019/05/07/Thr/</url>
    <content><![CDATA[<h1 id="Threadlocal实现原理"><a href="#Threadlocal实现原理" class="headerlink" title="Threadlocal实现原理"></a>Threadlocal实现原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ThreadLocal 用一种存储变量与线程绑定的方式，在每个线程中用自己的 ThreadLocalMap 安全隔离变量，为解决多线程程序的并发问题提供了一种新的思路，如为每个线程创建一个独立的数据库连接。因为是线程绑定的，所以在很多场景也被用来实现线程参数传递，如 Spring 的 RequestContextHolder。也因为每个线程拥有自己唯一的 ThreadLocalMap ，所以 <code>ThreadLocalMap 是天然线程安全的</code>。<br>来源：<a href="https://www.jianshu.com/p/56f64e3c1b6c" target="_blank" rel="noopener">简书</a></p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">           table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">           <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">           table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">           size = <span class="number">1</span>;</span><br><span class="line">           setThreshold(INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>每个线程持有自己的 ThreadLocalMap，ThreadLocalMap 初始容量为16，在调用ThreadLocal 的 set 方法时，将以 ThreadLocal 为 Key 存储在 本线程的 ThreadLocalMap 里面，ThreadLocalMap 的 Value 为Object 类型，实际类型由 ThreadLocal 定义。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">       <span class="comment">//key为当前ThreadLocal</span></span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//key为当前ThreadLocal</span></span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>getMap(t)方法获取了每个线程内部维护的ThreadLocals<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">        &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocalMap 是ThreadLocal 内部的一个Map实现，然而它并没有实现任何集合的接口规范，因为它仅供内部使用，数据结构采用 数组 + 开放地址法，Entry 继承 WeakReference，是基于 ThreadLocal 这种特殊场景实现的 Map。<br><code>WeakReference</code>如字面意思，弱引用， 当一个对象仅仅被weak reference（弱引用）指向, 而没有任何其他strong reference（强引用）指向的时候, 如果这时GC运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。</p>
<h3 id="Entry定义如下"><a href="#Entry定义如下" class="headerlink" title="Entry定义如下"></a>Entry定义如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Entry 继承 WeakReference，以 ThreadLocal 为 key，对内存敏感。虽然继承 WeakReference，但只能实现对 Reference 的 key 的回收，而对 value 的回收需要手动解决。value 何时被回收？ 如果没有理解 value 的回收时间，那可能留下内存溢出的隐患。</p>
<h3 id="ThreadLocalMap的hashCode计算"><a href="#ThreadLocalMap的hashCode计算" class="headerlink" title="ThreadLocalMap的hashCode计算"></a>ThreadLocalMap的hashCode计算</h3><p>ThreadLocalMap 的 key 是 ThreadLocal，但它不会传统的调用 ThreadLocal 的 hashCode 方法（继承自Object 的 hashCode），而是调用 nextHashCode() ，具体运算如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1640531527 这是一个神奇的数字，能够让hash槽位分布相当均匀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ThreadLocalMap 中 的 hashCode 全部使用 threadLocalHashCode 字段。threadLocalHashCode 用 final 修饰，不可变。threadLocalHashCode 的生成调用 nextHashCode()，所有 ThreadLocalMap 的 hashCode 使用静态的 AtomicInteger 每次增加 1640531527 来产生。<br>ThreadLocal 的 nextHashCode 是由 static 修饰的，他是一个共享变量，所有的 ThreadLocal 共享一个 AtomicInteger，在其基础上 CAS 增加。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2019/12/03/Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>存储类型<br>可以用来存储字符串、整数、浮点数</li>
<li>操作命令<br>设置值<br><code>set key value</code><br>设置多个值（批量操作，原子性）<br><code>mset key1 1111 key2 222</code><br>设置值，如果 key 存在，则不成功<br><code>setnx key</code><br>基于此可实现分布式锁。用 del key 释放锁。<br>但如果释放锁的操作失败了，导致其他节点永远获取不到锁，怎么办？<br>加过期时间。单独用 expire 加过期，也失败了，无法保证原子性，怎么办？多参数<br><code>set key value [expiration EX seconds|PX milliseconds][NX|XX]</code><br>使用参数的方式<br><code>set lock1 1 EX 10 NX</code><br>（整数）值递增<br><code>incr count
incrby count 100</code><br>（整数）值递减<br><code>decr count
decrby count 100</code><br>浮点数增量<br><code>set f 2.6
incrbyfloat f 7.3</code><br>获取多个值<br><code>mget key1 key2</code><br>获取值长度<br><code>strlen key1</code><br>字符串追加内容<br><code>append key1 xxxx</code><br>获取指定范围的字符<br><code>getrange key1 0 8</code><h4 id="存储（实现）原理"><a href="#存储（实现）原理" class="headerlink" title="存储（实现）原理"></a>存储（实现）原理</h4></li>
<li>数据模型<br>set hello word 为例，因为 Redis 是 KV 的数据库，它是通过 hashtable 实现的（我们把这个叫做外层的哈希）。所以每个键值对都会有一个 dictEntry（源码位置：dict.h），里面指向了 key 和 value 的指针。next 指向下一个dictEntry。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key; <span class="comment">/* key 关键字定义 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val; <span class="keyword">uint64_t</span> u64; <span class="comment">/* value 定义 */</span></span><br><span class="line">        <span class="keyword">int64_t</span> s64; <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">/* 指向下一个键值对节点*/</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://i.loli.net/2019/12/03/zfbJq6n51cvy92X.png" alt><br>key 是字符串，但是 Redis 没有直接使用 C 的字符数组，而是存储在自定义的 SDS中。<br>value 既不是直接作为字符串存储，也不是直接存储在 SDS 中，而是存储在redisObject 中。实际上五种常用的数据类型的任何一种，都是通过 redisObject 来存储的。</p>
<h4 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h4><p>redisObject 定义在 src/server.h 文件中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">/* 对象的类型，包括：OBJ_STRING、OBJ_LIST、OBJ_HASH、OBJ_SET、OBJ_ZSET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">/* 具体的数据结构 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* 24 位，对象最后一次被命令程序访问的时间，与内存回收有关 */</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">/* 引用计数。当 refcount 为 0 的时候，表示该对象已经不被任何对象引用，则可以进行垃圾回收了*/</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">/* 指向对象实际的数据结构 */</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>可以使用 type 命令来查看对外的类型。<br><code>127.0.0.1:6379&gt; type qs
string</code></p>
<h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><p><img src="https://i.loli.net/2019/12/03/IXxTDl5orE6si7k.png" alt><br><code>127.0.0.1:6379&gt; set number 1
OK
127.0.0.1:6379&gt; set qs &quot;is a good teacher in gupao, have crossed mountains and sea &quot;
OK
127.0.0.1:6379&gt; set jack bighead
OK
127.0.0.1:6379&gt; object encoding number
&quot;int&quot;
127.0.0.1:6379&gt; object encoding jack
&quot;embstr&quot;
127.0.0.1:6379&gt; object encoding qs
&quot;raw&quot;</code><br>字符串类型的内部编码有三种：<br>1、int，存储 8 个字节的长整型（long，2^63-1）。<br>2、embstr, 代表 embstr 格式的 SDS（Simple Dynamic String 简单动态字符串），存储小于 44 个字节的字符串。<br>3、raw，存储大于 44 个字节的字符串（3.2 版本之前是 39 字节）。</p>
<h4 id="什么是SDS？"><a href="#什么是SDS？" class="headerlink" title="什么是SDS？"></a>什么是SDS？</h4><p>Redis 中字符串的实现。<br>在 3.2 以后的版本中，SDS 又有多种结构（sds.h）：sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64，用于存储不同的长度的字符串，分别代表 2^5=32byte，2^8=256byte，2^16=65536byte=64KB，2^32byte=4GB。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sds.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* 当前字符数组的长度 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/*当前字符数组总共分配的内存大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 当前字符数组的属性、用来标识到底是 sdshdr8 还是 sdshdr16 等 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">/* 字符串真正的值 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="为什么-Redis-要用-SDS-实现字符串？"><a href="#为什么-Redis-要用-SDS-实现字符串？" class="headerlink" title="为什么 Redis 要用 SDS 实现字符串？"></a>为什么 Redis 要用 SDS 实现字符串？</h4><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>例如：热点数据缓存（例如报表，明星出轨），对象缓存，全页缓存。<br>可以提升热点数据的访问速度。</p>
<h5 id="数据共享、分布式"><a href="#数据共享、分布式" class="headerlink" title="数据共享、分布式"></a>数据共享、分布式</h5><p>STRING 类型<br>因为 Redis 是分布式的独立服务，可以在多个应用之间共享<br>例如：分布式 Session<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>STRING 类型 setnx 方法，只有不存在时才能添加成功，返回 true。<br>建议使用set key value 加参数形式</p>
<h5 id="全局ID"><a href="#全局ID" class="headerlink" title="全局ID"></a>全局ID</h5><p>INT 类型，INCRBY，利用原子性<br>incrby userid 1000<br>（分库分表的场景，一次性拿一段）</p>
<h5 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h5><p>INT 类型，INCR 方法<br>例如：文章的阅读量，微博点赞数，允许一定的延迟，先写入 Redis 再定时同步到数据库。</p>
<h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><p>以访问者的 IP 和其他信息作为 key，访问一次增加一次计数，超过次数则返回 false。</p>
<p><img src="/Redis/20191203042537799.png" alt></p>
]]></content>
  </entry>
  <entry>
    <title>JVM运行时内存划分</title>
    <url>/2019/02/13/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="运行时内存划分"><a href="#运行时内存划分" class="headerlink" title="运行时内存划分"></a>运行时内存划分</h1><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fmk5v19cmvj30g20anq3y.jpg" alt></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器：指向当前线程正在执行的字节码指令的地址、行号<br>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号显示器。在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此<code>为了线程切换后能恢复到正确的执行位置</code>，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，这类内存区域为<code>“线程私有”</code>的内存。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储<code>局部变量表、操作数栈、动态链接、方法出口</code>等信息。每一个方法从调用直至执行完成的过程，就对应着<code>一个栈帧在虚拟机栈中从入栈到出栈的过程</code>。</p>
<ul>
<li>如果出现方法递归调用出现死循环的话就会造成栈帧过多，最终会抛出 <code>StackOverflowError</code>。</li>
<li>若线程执行过程中栈帧大小超出虚拟机栈限制，则会抛出 <code>StackOverflowError</code>。</li>
<li>若虚拟机栈允许动态扩展，但在尝试扩展时内存不足，或者在为一个新线程初始化新的虚拟机栈时申请不到足够的内存，则会抛出 <code>OutOfMemoryError</code>。<a id="more"></a>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3>每一个栈帧都包括了局部变量表<code>局部变量表、操作数栈、动态链接、方法出口</code>和一些额外的附加信息。在程序编译的时候栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了。</li>
</ul>
<p><img src="https://i.loli.net/2019/02/21/5c6e0d2070d40.png" alt></p>
<p>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中<code>只有位于栈顶的栈帧才是有效的，称为当前栈帧</code>，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。<br>局部变量表存放了局部变量，包含了编译期可知的各种基本数据类型、引用类型（对象引用），基本类型存具体值，引用类型存引用地址，每个局部变量空间为32字节（long、double占两个局部变量空间），非static的实例方法的局部变量表中第0位索引默认是用于传递方法所属对象实例的引用，即this。=。<br>当方法中调用了其他方法时，例如A方法中调用了B方法，则调用A方法会压2个栈帧，如B方法中也调用了其他方法，以此类推。native方法压入本地方法栈 </p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表的Slot是可以被复用的，这种设计除了节省栈帧空间以外，还会有某些副作用，比如直接影响到系统的GC行为。</p>
<p><img src="https://i.loli.net/2019/02/21/5c6e14fbacf2b.png" alt></p>
<p>在上图代码中向内存填充了64M的数据然后通知虚拟机进行垃圾回收，在System.gc()运行后并没有回收这64M的内存。</p>
<p><img src="https://i.loli.net/2019/02/21/5c6e1860d1ae1.png" alt></p>
<p>将代码修改为上图，在加了大括号后bytes的作用域被限制在大括号内，从代码逻辑上讲在执行System.gc()的时候bytes已经不可能再被访问了，但在执行main方法后会发现这64M的内存还是没有被回收。</p>
<p><img src="https://i.loli.net/2019/02/21/5c6e19117b58d.png" alt></p>
<p>在代码改为如上图后，再次运行main方法可以发现这次内存被正确回收了。bytes能否被正确回收的根本原因是：局部变量表中的SLot是否还存在关于bytes的引用，第一次修改后（添加大括号），代码虽然已经离开了bytes的作用域，但在此之后没有任何对局部变量表的读写操作，bytes原本所占用的SLot还没有被其他变量所复用，所以作为GC Roots一部分的局部变量表仍然保持着对bytes的关联，这种关联没有被即使打断，在大部分情况下影响多很轻微，但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（代替int i = 1）便不见得是一个绝对无意义的操作。<br>为对象赋null值并不是控制变量回收的最好方法，以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法。另外，赋null值的操作在经过虚拟机JIT编译器优化后会被消除掉，经过JIT编译后，System.gc（）执行时就可以正确地回收掉内存，而无需赋null值。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈是一个先入后出的栈，同局部变量比奥一样操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32为数据所占栈容量为1，64位数据类型所占栈容量为2。<br>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈的操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的。<br>例如进行整数加法的字节码指令iadd前会将要相加的两个元素压入操作数栈最接近栈顶的两个元素，执行iadd这个指令时会将这两个int值出栈并相加，然后将相加的结果入栈。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用（静态解析），另一部分将在每一次运行期间转化为直接引用，这部分称为动态链接。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈为使用到的Native方法服务。与虚拟机栈一样，也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配，但随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么绝对了。<br>可利用参数<code>-Xms -Xmx</code>进行堆内存控制。<br>堆是内存分配的只要区域，从内存回收的角度看，由于现在收集器基本都采用<code>分代收集算法</code>，所以Java堆中还可以细分为<code>新生代</code>和<code>老年代</code>。</p>
<p>JDK1.8后原来存储在方法区（永久代）中的<code>静态变量、常量池</code>等也存在堆中</p>
<h2 id="方法区-JDK1-7"><a href="#方法区-JDK1-7" class="headerlink" title="方法区(JDK1.7)"></a>方法区(JDK1.7)</h2><p>方法区主要用于存放已经被虚拟机加载的类信息，如<code>常量，静态变量</code>。 这块区域也被称为永久代。</p>
<p>可利用参数 <code>-XX:PermSize -XX:MaxPermSize</code> 控制初始化方法区和最大方法区大小。</p>
<h2 id="元空间-JDK1-8"><a href="#元空间-JDK1-8" class="headerlink" title="元空间(JDK1.8)"></a>元空间(JDK1.8)</h2><p>在 JDK1.8 中已经移除了方法区永久代，并使用了元空间进行代替<code>（Metaspace）</code>。</p>
<p>默认情况下元数据区域会根据使用情况动态调整，避免了在 1.7 中由于加载类过多从而出现 <code>java.lang.OutOfMemoryError: PermGen</code>。</p>
<p>但也不能无线扩展，因此可以使用 <code>-XX:MaxMetaspaceSize</code>来控制最大内存。</p>
<p>元空间<code>属于本地内存、存储类的元信息</code>。</p>
<h2 id="Class文件常量池"><a href="#Class文件常量池" class="headerlink" title="Class文件常量池"></a>Class文件常量池</h2><p>运行时常量池是方法区的一部分。CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<code>常量池</code>，用于存放编译期生成的各种<code>字面量</code>和<code>符号引用</code>，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备<code>动态性</code>，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。<br>Class 文件常量池只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将<code>符号引用</code>解析为<code>直接引用</code>。<br>参考链接：<a href="https://www.zhihu.com/question/30300585/answer/51335493" target="_blank" rel="noopener">JVM里的符号引用如何存储？ - RednaxelaFX的回答 - 知乎</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/07/29/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="方法1：暴力法"><a href="#方法1：暴力法" class="headerlink" title="方法1：暴力法"></a>方法1：暴力法</h2><p>通过双层遍历找到与 target −<em>x</em> 相等的目标元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;nums.length;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> y = i+<span class="number">1</span>;y&lt;nums.length;y++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target - nums[i] == nums[y])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：O(n^2)</p>
<p>对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)的时间。因此时间复杂度为 O(n^2)。</p>
</li>
<li><p>空间复杂度：<em>O</em>(1)。</p>
</li>
</ul>
<h2 id="方法2：两边哈希表"><a href="#方法2：两边哈希表" class="headerlink" title="方法2：两边哈希表"></a>方法2：两边哈希表</h2><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p>
<p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p>
<p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]本身！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt;  map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;nums.length;i++)&#123;</span><br><span class="line">         map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;nums.length;i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> c = target - nums[i];</span><br><span class="line">         <span class="keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) != i) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(c),i&#125;;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三：一遍哈希表"><a href="#方法三：一遍哈希表" class="headerlink" title="方法三：一遍哈希表"></a>方法三：一遍哈希表</h2><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt;  map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;nums.length;i++)&#123;</span><br><span class="line">             <span class="keyword">int</span> c = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) != i) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(c),i&#125;;</span><br><span class="line">             &#125;</span><br><span class="line">            map.put(nums[i],i);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组 哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>中文开源项及优秀博客文章</title>
    <url>/2019/07/23/%E4%B8%AD%E6%96%87%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>本文只用作便于学习使用，如有侵权等请与我联系。</p>
<h4 id="Apache-Dubbo"><a href="#Apache-Dubbo" class="headerlink" title="Apache Dubbo"></a>Apache Dubbo</h4><p>分布式服务治理框架<br>中文官方文档： <a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a><br>github：<a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">https://github.com/apache/dubbo</a></p>
<h4 id="Alibaba-Nacous"><a href="#Alibaba-Nacous" class="headerlink" title="Alibaba Nacous"></a>Alibaba Nacous</h4><p>一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台<br>中文官方文档： <a href="https://nacos.io/zh-cn/index.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/index.html</a><br>github：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">https://github.com/alibaba/nacos</a></p>
<h4 id="dubbo外部化配置"><a href="#dubbo外部化配置" class="headerlink" title="dubbo外部化配置"></a>dubbo外部化配置</h4><p>小马哥的博客：<a href="https://mercyblitz.github.io/2018/01/18/Dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">https://mercyblitz.github.io/2018/01/18/Dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/</a></p>
]]></content>
      <categories>
        <category>开源文档</category>
      </categories>
      <tags>
        <tag>开源文档</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁和悲观所的原理及应用</title>
    <url>/2019/02/11/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E6%89%80%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h2><p>在CPU层面引入了高速缓存以及在多核心cpu下线程并行执行时导致的<code>缓存一致性问题</code>，通过总线锁或缓存锁的方式来保证缓存的一致性。锁的核心理念是一个同步机制，是保证进行多线程并行执行的时候对共享资源访问的安全性。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p> 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用<code>version</code>或<code>CAS</code>操作实现。</p>
<h3 id="version方式"><a href="#version方式" class="headerlink" title="version方式"></a>version方式</h3><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<h3 id="CAS方式"><a href="#CAS方式" class="headerlink" title="CAS方式"></a>CAS方式</h3><p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁（不使用多线程锁，基于cpu锁）的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<pre><code>需要读写的内存值 V
进行比较的值 A
拟写入的新值 B
</code></pre><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p> 乐观锁相信事务之间的数据竞争的概率是非常小的，因此做很多操作的时候是不需要进行加锁的，只在数据进行提交以后才会进行一些锁的判断，性能较高，不会产生锁和死锁</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。如下所示：<br><a id="more"></a><br><img src="https://i.loli.net/2019/02/11/5c6134116d436.png" alt><br>　现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：<br>            head.compareAndSet(A,B);<br>    在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，此时堆栈结构如下图，而对象B此时处于游离状态：<br>    <img src="https://i.loli.net/2019/02/11/5c61344b5b2e5.png" alt><br>    此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上B.next为null，所以此时的情况变为：<br>    <img src="https://i.loli.net/2019/02/11/5c6134700e69e.png" alt><br>    其中堆栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，平白无故就把C、D丢掉了。<br>    从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">2</span>                V      expectedReference,//预期引用</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">3</span> </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">4</span>                V      newReference,//更新后的引用</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">5</span> </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">6</span>               <span class="keyword">int</span>    expectedStamp, //预期标志</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">7</span> </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">8</span>               <span class="keyword">int</span>    newStamp //更新后的标志</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">9</span> )</span></span></span><br></pre></td></tr></table></figure></p>
<p>实际应用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> ........</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>   每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待,JAVA的synchronized关键字就是一种悲观锁。</p>
<p>以常用的mysql InnoDB存储引擎为例：加入商品表items表中有一个字段status，status=1表示该商品未被下单，status=2表示该商品已经被下单，那么我们对每个商品下单前必须确保此商品的status=1。假设有一件商品，其id为10000；如果不使用锁，那么操作方法如下：<br>       //查出商品状态<br>       select status from items where id=10000;<br>       //根据商品信息生成订单<br>       insert into orders(id,item_id) values(null,10000);<br>       //修改商品状态为2<br>       update Items set status=2 where id=10000;<br>       上述场景在高并发环境下可能出现问题：<br>       前面已经提到只有商品的status=1是才能对它进行下单操作，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步update操作的时候，有可能出现其他人先一步对商品下单把Item的status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。<br>       使用悲观锁来实现：在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出items信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为items被锁定了，就不会出现有第三者来对其进行修改了。<br>        注：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。我们可以使用命令设置MySQL为非autocommit模式：<br>       <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line">设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><br><span class="line">//开始事务</span><br><span class="line"><span class="keyword">begin</span>;/<span class="keyword">begin</span> <span class="keyword">work</span>;/<span class="keyword">start</span> <span class="keyword">transaction</span>; (三者选一就可以)</span><br><span class="line">//查询出商品信息</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10000</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">//根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (<span class="keyword">id</span>,item_id) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="number">10000</span>);</span><br><span class="line">//修改商品status为2</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10000</span>;</span><br><span class="line">//提交事务</span><br><span class="line"><span class="keyword">commit</span>;/<span class="keyword">commit</span> <span class="keyword">work</span>;</span><br></pre></td></tr></table></figure></p>
<p> 悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。</p>
<h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><h4 id="悲观锁-1"><a href="#悲观锁-1" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p>
<h4 id="乐观锁-1"><a href="#乐观锁-1" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>两种所各有优缺点，读取频繁使用乐观锁，写入频繁使用悲观锁。</p>
<p>像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适,之所以用悲观锁就是因为两个用户更新同一条数据的概率高，也就是冲突比较严重的情况下，所以才用悲观锁.</p>
<p>悲观锁比较适合强一致性的场景，但效率比较低，特别是读的并发低。乐观锁则适用于读多写少，并发冲突少的场景。</p>
]]></content>
      <categories>
        <category>锁</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/24/kafka/</url>
    <content><![CDATA[<h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><p>高性能、高吞吐</p>
<p>不是基于jms的实现</p>
<p>内置分区、实现集群-区别于activeMQ</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/Users/zhangjunmin/Library/Application Support/typora-user-images/image-20201013100607380.png" alt="image-20201013100607380"></p>
<p>Topic:主题</p>
<p>partion:数据分区</p>
<p>group:消费端所属</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>acks</p>
<p>0:消息发送给broker后，不需要确认（性能较高，但是会出现数据丢失）</p>
<p>1:只需要得到kafka集群中leader节点的确认即可返回（leader/follower）</p>
<p>all（-1）：需要集群中的所有节点确认（最安全但性能低，也有可能会出现数据丢失）</p>
<p>batch.size</p>
]]></content>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2019/03/16/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h2><p>在生活中，我们经常见到这样的场景，如：租房中介、售票黄牛、婚介、经纪人、快递、事务代理、非侵入式日志监听等，这些都是代理模式的实际体现。<code>代理模式（ProxyPattern）</code>的定义也非常简单，是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客服端和目标对象之间起到中介作用，代理模式属于结构型设计模式。使用代理模式主要有两个目的：一保护目标对象，二增强目标对象。下面我们来看一下代理模式的类结构图：<br><img src="https://i.loli.net/2019/03/16/5c8c9aba772a1.png" alt><br>Subject 是顶层接口，RealSubject 是真实对象（被代理对象），Proxy 是代理对象，代理对象持有被代理对象的引用，客户端调用代理对象方法，同时也调用被代理对象的方法，但是在代理对象前后增加一些处理。在代码中，我们想到代理，就会理解为是代码增强，其实就是在原本逻辑前后增加一些逻辑，而调用者无感知。代理模式属于结构型模式，有静态代理和动态代理。<br><a id="more"></a></p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在分布式业务场景中，我们通常会对数据库进行分库分表，<br>分库分表之后使用 Java 操作时，就可能需要配置多个数据源，我们通过设置数据源路由来动态切换数据源。先创建 Order 订单实体：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object orderInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getOrderInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderInfo</span><span class="params">(Object orderInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderInfo = orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateTime</span><span class="params">(Long createTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 OrderDao 持久层操作类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"OrderDao 创建 Order 成功!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 IOrderService 接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 OrderService 实现类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> <span class="keyword">implements</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果使用 Spring 应该是自动注入的</span></span><br><span class="line">    <span class="comment">//我们为了使用方便，在构造方法中将 orderDao 直接初始化了</span></span><br><span class="line">    orderDao = <span class="keyword">new</span> OrderDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"OrderService 调用 orderDao 创建订单"</span>);</span><br><span class="line">    <span class="keyword">return</span> orderDao.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来使用静态代理，主要完成的功能是，根据订单创建时间自动按年进行分库。根据开闭原则，原来写好的逻辑我们不去修改，通过代理对象来完成。先创建数据源路由对象，我们使用 ThreadLocal 的单例实现，DynamicDataSourceEntry 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 动态切换数据源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceEntry</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认数据源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_SOURCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DynamicDataSourceEntry</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清空数据源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    local.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前正在使用的数据源名字</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> local.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 还原当前切面的数据源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    local.set(DEFAULT_SOURCE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置已知名字的数据源</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">    local.set(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据年份动态设置数据源</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> year</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">    local.set(<span class="string">"DB_"</span> + year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建切换数据源的代理 OrderServiceSaticProxy 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceStaticProxy</span> <span class="keyword">implements</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat yearFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy"</span>);</span><br><span class="line">    <span class="keyword">private</span> IOrderService orderService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderServiceStaticProxy</span><span class="params">(IOrderService orderService)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    before();</span><br><span class="line">    Long time = order.getCreateTime();</span><br><span class="line">    Integer dbRouter = Integer.valueOf(yearFormat.format(<span class="keyword">new</span> Date(time)));</span><br><span class="line">    System.out.println(<span class="string">"静态代理类自动分配到【DB_"</span> + dbRouter + <span class="string">"】数据源处理数据。"</span>);</span><br><span class="line">    DynamicDataSourceEntry.set(dbRouter);</span><br><span class="line">    orderService.createOrder(order);</span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Proxy before method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Proxy after method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来看测试代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    <span class="comment">// Date today = new Date();</span></span><br><span class="line">    <span class="comment">// order.setCreateTime(today.getTime());</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">    Date date = sdf.parse(<span class="string">"2017/02/01"</span>);</span><br><span class="line">    order.setCreateTime(date.getTime());</span><br><span class="line">    IOrderService orderService = <span class="keyword">new</span> OrderServiceStaticProxy(<span class="keyword">new</span> OrderService());</span><br><span class="line">    orderService.createOrder(order);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="https://i.loli.net/2019/03/19/5c908b9042070.png" alt><br>符合预期效果。现在再来回顾一下类图，看是不是和最先画的类结构一致：<br><img src="https://i.loli.net/2019/03/19/5c908bae184df.png" alt></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理和静态对比基本思路是一致的，只不过动态代理功能更加强大，随着业务的扩展适应性更强。如果还以找对象为例，使用动态代理相当于是能够适应复杂的业务场景。不仅仅只是父亲给儿子找对象，如果找对象这项业务发展成了一个产业，进而出现了媒婆、婚介所等这样的形式。那么，此时用静态代理成本就更大了，需要一个更加通用的解决方案，要满足任何单身人士找对象的需求。我们升级一下代码，先来看 JDK 实现方式：</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>动态代理,动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2019/03/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p><code>简单工厂模式</code>（Simple Factory Pattern）是指由一个工厂对象决定创建出哪一种产品类的实例，但它不属于 GOF，23 种设计模式式（参考资料：<br><a href="http://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type）。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type）。</a><br>简单工厂适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。<br>简单工厂的缺点：工厂类的职责相对过重，不易于扩展过于复杂的产品结构。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>以课程为例。咕泡学院目前开设有 Java 架构、大数据、人<br>工智能等课程，已经形成了一个生态。我们可以定义一个课程标准 ICourse 接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">录制视频 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个 Java 课程的实现 JavaCourse 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"录制 Java 课程"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看客户端调用代码，我们会这样写：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ICourse course = <span class="keyword">new</span> JavaCourse();</span><br><span class="line">course.record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上面的代码，父类 ICourse 指向子类 JavaCourse 的引用，应用层代码需要依赖JavaCourse，如果业务扩展，我继续增加 PythonCourse 甚至更多，那么我们客户端的依赖会变得越来越臃肿。因此，我们要想办法把这种依赖减弱，把创建细节隐藏。虽然目前的代码中，我们创建对象的过程并不复杂，但从代码设计角度来讲不易于扩展。现在，我们用简单工厂模式对代码进行优化。<br><a id="more"></a><br>先增加课程 PythonCourse 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"录制 Python 课程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 CourseFactory 工厂类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICourse <span class="title">create</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"java"</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JavaCourse();</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"python"</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PythonCourse();</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改客户端调用代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CourseFactory factory = <span class="keyword">new</span> CourseFactory();</span><br><span class="line">    factory.create(<span class="string">"java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端调用是简单了，但如果我们业务继续扩展，要增加前端课程，那么工厂中的<br>create()就要根据产品链的丰富每次都要修改代码逻辑。不符合开闭原则。因此，我们<br>对简单工厂还可以继续优化，可以采用反射技术：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ICourse <span class="title">create</span><span class="params">(Class&lt;? extends ICourse&gt; clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != clazz) &#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化客户端代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CourseFactory factory = <span class="keyword">new</span> CourseFactory();</span><br><span class="line">ICourse course = factory.create(JavaCourse<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">course.record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类图：<br><img src="https://i.loli.net/2019/03/07/5c80c65aabf5f.png" alt><br>经常使用的日志工具LoggerFactory中就使用的简单工厂模式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory();</span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLogger(clazz.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/JunminZhang/pattern/blob/master/src/main/java/com/zjm/pattern/factory/simplefactory/SimpleFactoryTest.java" target="_blank" rel="noopener">代码示例</a></p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><code>工厂方法模式</code>（Fatory Method Pattern）是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符合<code>开闭原则</code>。<br>工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着<code>产品链</code>的丰富，如果每个课程的创建逻辑有区别的话，工厂的职责会变得越来越多，有点像万能工厂，并不便于维护。根据<code>单一职责</code>原则我们将职能继续拆分，专人干专事。Java 课程由 Java 工厂创建，Python 课程由 Python 工厂创建，对工厂本身也做一个抽象。来看代码，先<br>创建 ICourseFactory 接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ICourse <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在分别创建子工厂，JavaCourseFactory 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourseFactory</span> <span class="keyword">implements</span> <span class="title">ICourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICourse <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JavaCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PythonCourseFactory 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonCourseFactory</span> <span class="keyword">implements</span> <span class="title">ICourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICourse <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PythonCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看测试代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ICourseFactory factory = <span class="keyword">new</span> PythonCourseFactory();</span><br><span class="line">    ICourse course = factory.create();</span><br><span class="line">    course.record();</span><br><span class="line">    factory = <span class="keyword">new</span> JavaCourseFactory();</span><br><span class="line">    course = factory.create();</span><br><span class="line">    course.record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>工厂方法适用于以下场景：<br>1、创建对象需要大量重复的代码。<br>2、客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。<br>3、一个类通过其子类来指定创建哪个对象。<br>工厂方法也有缺点：<br>1、类的个数容易过多，增加复杂度。<br>2、增加了系统的抽象性和理解难度。<br><a href="https://github.com/JunminZhang/pattern/blob/master/src/main/java/com/zjm/pattern/factory/factorymethod/FactoryMethodTest.java" target="_blank" rel="noopener">代码示例</a></p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><code>抽象工厂模式</code>（Abastract Factory Pattern）是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。<br>还是以课程为例，<br>每个课程不仅要提供课程的录播视频，而且还要提供老师的课堂笔记。<br>相当于现在的业务变更为同一个课程不单纯是一个课程信息，要同时包含录播视频、课堂笔记甚至还要提供源码才能构成一个完整的课程。在产品等级中增加两个产品<br>IVideo 录播视频和 INote 课堂笔记。<br>IVideo 接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVideo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>INote 接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INote</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后创建一个抽象工厂 CourseFactory 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抽象工厂是用户的主入口</span></span><br><span class="line"><span class="comment">* 在 Spring 中应用得最为广泛的一种设计模式</span></span><br><span class="line"><span class="comment">* 易于扩展</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">INote <span class="title">createNote</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">IVideo <span class="title">createVideo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，创建 Java 产品族，Java 视频 JavaVideo 类:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVideo</span> <span class="keyword">implements</span> <span class="title">IVideo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"录制 Java 视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>扩展产品等级 Java 课堂笔记 JavaNote 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaNote</span> <span class="keyword">implements</span> <span class="title">INote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"编写 Java 笔记"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 Java 产品族的具体工厂 JavaCourseFactory:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourseFactory</span> <span class="keyword">implements</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> INote <span class="title">createNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JavaNote();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> IVideo <span class="title">createVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JavaVideo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后创建 Python 产品，Python 视频 PythonVideo 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonVideo</span> <span class="keyword">implements</span> <span class="title">IVideo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"录制 Python 视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>扩展产品等级 Python 课堂笔记 PythonNote 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonNote</span> <span class="keyword">implements</span> <span class="title">INote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"编写 Python 笔记"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 Python 产品族的具体工厂 PythonCourseFactory:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonCourseFactory</span> <span class="keyword">implements</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> INote <span class="title">createNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PythonNote();</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IVideo <span class="title">createVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PythonVideo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看客户端调用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JavaCourseFactory factory = <span class="keyword">new</span> JavaCourseFactory();</span><br><span class="line">    factory.createNote().edit();</span><br><span class="line">    factory.createVideo().record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/JunminZhang/pattern/blob/master/src/main/java/com/zjm/pattern/factory/abstractfactory/AbstractFactoryTest.java" target="_blank" rel="noopener">代码示例</a><br>上面的代码完整地描述了两个产品族 Java 课程和 Python 课程，也描述了两个产品等级视频和手记。抽象工厂非常完美清晰地描述这样一层复杂的关系。但是，如果我们再继续扩展产品等级，将源码 Source 也加入到课程中，那么我们的代码从抽象工厂，到具体工厂要全部调整，很显然不符合开闭原则。因此抽象<br>工厂也是有缺点的：<br>1、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。<br>2、增加了系统的抽象性和理解难度。<br>但在实际应用中，我们千万不能犯强迫症甚至有洁癖。在实际需求中产品等级结构升级是非常正常的一件事情。我们可以根据实际情况，只要不是频繁升级，可以不遵循开闭原则。代码每半年升级一次或者每年升级一次又有何不可呢？</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/03/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h2><p><code>单例模式</code>（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。例如，国家主席、公司 CEO、部门经理等。在 J2EE 标准<code>ServletContext</code>、<br><code>ServletContextConfig</code> 等；在 Spring 框架应用中<code>ApplicationContext</code>；数据库的连接池也都是单例形式。</p>
<h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><p>饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题。<br>优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。<br>缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅坑不拉屎。<br>类图：<img src="https://i.loli.net/2019/03/11/5c860b8758021.png" alt><br>Spring 中 IOC 容器 ApplicationContext 本身就是典型的饿汉式单例。接下来看一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySing</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySing hungrySing = <span class="keyword">new</span> HungrySing();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySing <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外一种写法，利用静态代码块的机制：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySing</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySing hungrySing ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        hungrySing =  <span class="keyword">new</span> HungrySing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySing <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><p><code>懒汉式单例</code>的特点是：<code>被外部类调用的时候才会加载</code>，下面看懒汉式单例的简单实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySimpleSing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySimpleSing lazySing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySimpleSing <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazySing == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lazySing = <span class="keyword">new</span> LazySimpleSing();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后写一个线程类 ExectorThread 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExectorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LazySimpleSing lazySimpleSing = LazySimpleSing.getInstance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":----"</span>+lazySimpleSing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端测试代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSignTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="https://i.loli.net/2019/03/11/5c860b874dc97.png" alt><br>一定几率出现创建两个不同结果的情况，意味着上面的单例存在线程安全隐患。然后使用调试运行再具体看一下，使用IDEA线程模式调试，手动控制线程的执行顺序来跟踪内存的变化状态。先给 ExectorThread 类打上断点：<br><img src="https://i.loli.net/2019/03/11/5c863362cbfe1.png" alt><br>右键点击断点，切换为 Thread 模式，如下图：<br><img src="https://i.loli.net/2019/03/11/5c863362cecc9.png" alt><br>然后，给 LazySimpleSing 类打上断点，同样标记为 Thread 模式：<br><img src="https://i.loli.net/2019/03/11/5c863362cd1a8.png" alt><br>切回到客户端测试代码，同样也打上断点，同时改为 Thread 模式，如下图:<br><img src="https://i.loli.net/2019/03/11/5c863362cd6ff.png" alt><br>开始 debug 之后，会看到 debug 控制台可以自由切换 Thread 的运行状态：<br><img src="https://i.loli.net/2019/03/11/5c863362c9902.png" alt><br>通过不断切换线程，并观测其内存状态，我们发现在线程环境下 LazySimpleSing。有时，我们得到的运行结果可能是相同的两个对象，实际上是被后面执行的线程覆盖了，我们看到了一个假象，线程安全隐患依旧存在。那么，我们如何来优化代码，使得懒汉式单例在线程环境下安全呢？来看下面的代码，给 getInstance()加上 synchronized 关键字，使这个方法变成线程同步方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySimpleSing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySimpleSing lazySing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySimpleSing <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazySing == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lazySing = <span class="keyword">new</span> LazySimpleSing();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候，我们再来调试。当我们将其中一个线程执行并调用 getInstance()方法时，另一个线程在调用 getInstance()方法，线程的状态由 RUNNING 变成了 <code>MONITOR</code>,出现阻塞。直到第一个线程执行完，第二个线程才恢复 RUNNING 状态继续调用 getInstance()方法。如下图所示：<br><img src="https://i.loli.net/2019/03/11/5c86336349cf4.png" alt><br>完美的展现了 <code>synchronized 监视锁</code>的运行状态，线程安全的问题便解决了。但是，用synchronized 加锁，在线程数量比较多情况下，如果 CPU 分配压力上升，会导致大批量线程出现阻塞，从而导致程序运行性能大幅下降。那么，有没有一种更好的方式，既兼顾线程安全又提升程序性能呢？答案是肯定的。我们来看双重检查锁的单例模式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSing lazySing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSing <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazySing == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSing<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazySing == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lazySing = <span class="keyword">new</span> LazyDoubleCheckSing();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当第一个线程调用 getInstance()方法时，第二个线程也可以调用 getInstance()。当第一个线程执行到 synchronized 时会上锁，第二个线程就会变成 <code>MONITOR</code> 状态，出现阻塞。此时，阻塞并不是基于整个 LazySimpleSing 类的阻塞，而是在 getInstance()方法内部阻塞，只要逻辑不是太复杂，对于调用者而言感知不到。<br>但是，用到 synchronized 关键字，总归是要上锁，对程序性能还是存在一定影响的。难道就真的没有更好的方案吗？当然是有的。我们可以从类初始化角度来考虑，看下面的代码，采用静态内部类的方式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInnerClassSing</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSing <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.LAZY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSing LAZY = <span class="keyword">new</span> LazyInnerClassSing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="反射破坏单例"><a href="#反射破坏单例" class="headerlink" title="反射破坏单例"></a>反射破坏单例</h2><p>上面介绍的单例模式的构造方法除了加上 private 以外，没有做任何处理。如果我们使用反射来调用其构造方法，然后，再调用 getInstance()方法，应该就会两个不同的实例。现在来看一段测试代码，以 LazyInnerClassSingleton 为例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//很无聊的情况下，进行破坏</span></span><br><span class="line">        Class&lt;?&gt; clazz = LazyInnerClassSing<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//通过反射拿到私有的构造方法</span></span><br><span class="line">        Constructor c = clazz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//强制访问，强吻，不愿意也要吻</span></span><br><span class="line">        c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//暴力初始化</span></span><br><span class="line">        Object o1 = c.newInstance();</span><br><span class="line">        <span class="comment">//调用了两次构造方法，相当于 new 了两次</span></span><br><span class="line">        <span class="comment">//犯了原则性问题，</span></span><br><span class="line">        Object o2 = c.newInstance();</span><br><span class="line">        System.out.println(o1 == o2);</span><br><span class="line">        <span class="comment">// Object o2 = c.newInstance();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们在其构造方法中做一些限制，一旦出现多次重复创建，则直接抛出异常。来看优化后的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInnerClassSing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LazyHolder.LAZY != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许创建多个实例"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSing <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.LAZY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSing LAZY = <span class="keyword">new</span> LazyInnerClassSing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述写法可以防止被反射恶意或意外破坏单例</p>
<h2 id="序列化破坏单例"><a href="#序列化破坏单例" class="headerlink" title="序列化破坏单例"></a>序列化破坏单例</h2><p>当我们将一个单例对象创建好，有时候需要将对象序列化然后写入到磁盘，下次使用时再从磁盘中读取到对象，反序列化转化为内存对象。反序列化后的对象会重新分配内存，即重新创建。那如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当于破坏了单例，来看一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSing</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> SeriableSing INSTANCE = <span class="keyword">new</span> SeriableSing();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SeriableSing</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeriableSing <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写测试代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SeriableSing s1 = <span class="keyword">null</span>;</span><br><span class="line">        SeriableSing s2 = SeriableSing.getInstance();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"SeriableSing.obj"</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(s2);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"SeriableSing.obj"</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            s1 = (SeriableSing)ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">            System.out.println(s2);</span><br><span class="line">            System.out.println(s1 == s2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="https://i.loli.net/2019/03/11/5c863363392c9.png" alt><br>运行结果中，可以看出，反序列化后的对象和手动创建的对象是不一致的，实例化了两次，违背了单例的设计初衷。那么，我们如何保证序列化的情况下也能够实现单例？其实很简单，只需要增加 readResolve()方法即可。来看优化代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSing</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> SeriableSing INSTANCE = <span class="keyword">new</span> SeriableSing();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SeriableSing</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeriableSing <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次运行结果：<br><img src="https://i.loli.net/2019/03/11/5c86336335857.png" alt><br>这是什么原因呢？为什么要这样写？看上去很神奇的样子，也让人有些费解。进入JDK源码ObjectInputStream 类的 readObject()方法，代码如下：<br><img src="https://i.loli.net/2019/03/11/5c8635a292905.png" alt><br>我们发现在readObject中又调用了我们重写的readObject0()方法。进入readObject0()方法，代码如下<br><img src="https://i.loli.net/2019/03/11/5c8635a275a63.png" alt><br>我们看到 TC_OBJECTD 中判断，调用了 ObjectInputStream 的 readOrdinaryObject()方法，我们继续进入看源码：<br><img src="https://i.loli.net/2019/03/11/5c8635a28e1a8.png" alt><br>发现调用了 ObjectStreamClass 的 isInstantiable()方法，而 isInstantiable()里面的代码如下：<br><img src="https://i.loli.net/2019/03/11/5c8635a26a85f.png" alt><br>代码非常简单，就是判断一下构造方法是否为空，构造方法不为空就返回 true。意味着，只要有无参构造方法就会实例化。这时候，其实还没有找到为什么加上 readResolve()方法就避免了单例被破坏的真正原因。我再回到 ObjectInputStream 的readOrdinaryObject()方法继续往下看：<br><img src="https://i.loli.net/2019/03/11/5c8635a279e10.png" alt><br>判断无参构造方法是否存在之后，又调用了 hasReadResolveMethod()方法，来看代码：<br><img src="https://i.loli.net/2019/03/11/5c8635a2c4cb2.png" alt><br>逻辑非常简单，就是判断 readResolveMethod 是否为空，不为空就返回 true。那么readResolveMethod 是在哪里赋值的呢？通过全局查找找到了赋值代码在私有方法ObjectStreamClass()方法中给 readResolveMethod 进行赋值，来看代码：<br><img src="https://i.loli.net/2019/03/11/5c8635a2d7392.png" alt><br>上面的逻辑其实就是通过反射找到一个无参的 readResolve()方法，并且保存下来。现在再回到ObjectInputStream的 readOrdinaryObject()方法继续往下看，如果readResolve()存在则调用 invokeReadResolve()方法，来看代码：<br><img src="https://i.loli.net/2019/03/11/5c8635a3045ae.png" alt><br>我们可以看到在invokeReadResolve()方法中用反射调用了readResolveMethod方法。通过 JDK 源码分析我们可以看出，虽然，增加 readResolve()方法返回实例，解决了单例被破坏的问题。但是，我们通过分析源码以及调试，我们可以看到实际上实例化了两次，只不过新创建的对象没有被返回而已。创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大，下面介绍一种注册式单例，也许能从根本上解决问题。</p>
<h2 id="注册式单例"><a href="#注册式单例" class="headerlink" title="注册式单例"></a>注册式单例</h2><p><code>注册式单例</code>又称为<code>登记式单例</code>，就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。注册式单例有两种写法：一种为<code>容器缓存</code>，一种为<code>枚举登记</code>。先来看枚举式单例的写法，来看代码，创建 <code>EnumSingleton</code> 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSing &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSing <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来看测试代码：<br><img src="https://i.loli.net/2019/03/11/5c8676d54b973.png" alt><br>没有做任何处理，我们发现运行结果和我们预期的一样。那么枚举式单例如此神奇，它的神秘之处在哪里体现呢？下面我们通过分析源码来揭开它的神秘面纱。<br>使用 Java 反编译工具 Jad（下载地址：<a href="https://varaneckas.com/jad/" target="_blank" rel="noopener">https://varaneckas.com/jad/</a> ） 反编译EnumSing.class可以看到：<br><img src="https://i.loli.net/2019/03/11/5c8676d51bcba.png" alt><br>原来，枚举式单例在静态代码块中就给 INSTANCE 进行了赋值，是饿汉式单例的实现。<br>那么序列化我们能否破坏枚举式单例呢？我们不妨再来看一下 JDK源码，还是回到 ObjectInputStream 的 readObject0()方法：<br><img src="https://i.loli.net/2019/03/11/5c8676d5174ea.png" alt><br>我们看到在 readObject0()中调用了 readEnum()方法，来看 readEnum()中代码实现：<br><img src="https://i.loli.net/2019/03/11/5c8676d53ea28.png" alt><br>我们发现枚举类型其实通过类名和 Class 对象类找到一个唯一的枚举对象。因此，枚举对象不可能被类加载器加载多次。<br>下面来看看反射是否能破坏枚举式单例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Class clazz = EnumSing<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">               Constructor c = clazz.getDeclaredConstructor();</span><br><span class="line">               c.newInstance();</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="https://i.loli.net/2019/03/11/5c8676d53366f.png" alt><br>报的是 java.lang.NoSuchMethodException 异常，意思是没找到无参的构造方法。这时候，我们打开 java.lang.Enum 的源码代码，查看它的构造方法，只有一个 protected的构造方法，代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那我们再来做一个这样的测试：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Class clazz = EnumSing<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">               Constructor c = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">               c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">               EnumSing enumSingleton = (EnumSing)c.newInstance(<span class="string">"zjm"</span>,<span class="number">666</span>);</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="https://i.loli.net/2019/03/11/5c8676d576b5c.png" alt><br>这时错误已经非常明显了，告诉我们 Cannot reflectively create enum objects不能用反射来创建枚举类型。还是习惯性地想来看看 JDK 源码，进入 Constructor 的newInstance()方法：<br><img src="https://i.loli.net/2019/03/11/5c8676d5a9bec.png" alt><br>在 newInstance()方法中做了强制性的判断，如果修饰符是 Modifier.ENUM 枚举类型，直接抛出异常。到这为止，我们是不是已经非常清晰明了呢？枚举式单例也是《EffectiveJava》书中推荐的一种单例实现写法。在 JDK 枚举的语法特殊性，以及反射也为枚举保驾护航，让枚举式单例成为一种比较优雅的实现。</p>
<h2 id="容器式单例"><a href="#容器式单例" class="headerlink" title="容器式单例"></a>容器式单例</h2><p><code>容器式单例</code>是<code>注册式单例</code>的另一种写法，首先创建 ContainerSing 类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ioc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ioc.containsKey(className)) &#123;</span><br><span class="line">                Object object = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object = Class.forName(className).newInstance();</span><br><span class="line">                    ioc.put(className, object);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ioc.get(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Spring中的容器式单例的实现代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Cache of unfinished FactoryBean instances: FactoryBean name --&gt; BeanWrapper */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanWrapper&gt; factoryBeanInstanceCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ThreadLocal-线程单例"><a href="#ThreadLocal-线程单例" class="headerlink" title="ThreadLocal 线程单例"></a>ThreadLocal 线程单例</h2><p>ThreadLocal 不能保证其创建的对象是全局唯一，但是能保证在单个线程中是唯一的，天生的线程安全。<br>代码示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalSing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalSing&gt; threadLocalInstance = <span class="keyword">new</span> ThreadLocal&lt;ThreadLocalSing&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> ThreadLocalSing <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalSing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalSing</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalSing <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocalInstance.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadLocal将所有的对象全部放在 ThreadLocalMap 中，为每个线程都提供一个对象，实际上是以空间换时间来实现线程间隔离的。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式,单例</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务的解决方案</title>
    <url>/2019/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul>
<li>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
<li>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。<h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3></li>
</ul>
<h4 id="X-open-DTP-分布式事务模型"><a href="#X-open-DTP-分布式事务模型" class="headerlink" title="X/open DTP 分布式事务模型"></a>X/open DTP 分布式事务模型</h4><p>X/Open 这个组织定义的一套分布式事务的标准，也就是定义了规范和 API 接口，由各个厂商进行具体的实现。<br>这个标准提出了使用二阶段提交(2PC – Two-Phase-Commit)来保证分布式事务的完整性。后来 J2EE 也遵循了 X/OpenDTP 规范，设计并实现了 java 里的分布式事务编程接口规范-JTA</p>
<h4 id="X-OpenDTP"><a href="#X-OpenDTP" class="headerlink" title="X/OpenDTP"></a>X/OpenDTP</h4><p><img src="/分布式事务的解决方案/20191123031904756.png" alt><br>在 X/OpenDTP 事务模型中，定义了三个角色<br>AP: application, 应用程序，也就是业务层。哪些操作属于一个事务，就是 AP 定义的</p>
<p>RM： Resource Manager，资源管理器。一般是数据库，也可以是其他资源管理器，比如消息队列，文件系统</p>
<p>TM： Transaction Manager ，事务管理器、事务协调者，负责接收来自用户程序（AP）发起的 XA 事务指令，并调度和协调参与事务的所有 RM（数据库），确保事务正确完成</p>
<p>在分布式系统中，每一个机器节点虽然都能够明确知道自己在进行事务操作过程中的结果是成功还是失败，但却无法直接获取到其他分布式节点的操作结果。因此当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 特性，就需要引入一个“协调者”（TM）来统一度所有分布式节点的执行逻辑，这些被调度的分布式节点被称为 AP。TM 负责调度 AP 的行为，并最终决定这些 AP 是否要把事务真正进行提交到（RM）</p>
<ul>
<li>1.参与分布式事务的应用程序(AP)先到 TM 上注册全局事务</li>
<li>2.然后各个 AP 直接在相应的资源管理器(RM)上进行事务操作</li>
<li>3.操作完成以后，各个 AP 反馈事务的处理结果给到 TM</li>
<li>4.TM 收到所有 AP 的反馈以后，通过数据库提供的 XA 接口进行数据提交或者回</li>
</ul>
<h4 id="2pc提交（two-phaseCommit-）"><a href="#2pc提交（two-phaseCommit-）" class="headerlink" title="2pc提交（two -phaseCommit ）"></a>2pc提交（two -phaseCommit ）</h4><p>在 X/OpenDTP 模型中，一个分布式事务所涉及的 SQL 逻辑都执行完成，并到了（RM）要最后提交事务的关键时刻，为了避免分布式系统所固有的不可靠性导致提交事务意外失败，TM 果断决定实施两步走的方案，这个就称为二阶提交二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下<br>的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务 AP 的协调，统一决定事务的提交或回滚，从而能够有效保证分布式数据一致性，因此 2pc 也被广泛运用在许多分布式系统中。</p>
<h5 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h5><p> <img src="/分布式事务的解决方案/20191123032811372.png" alt></p>
<ul>
<li><ol>
<li>事务询问<br>TM 向所有的 AP 发送事务内容，询问是否可以执行事务提交操作，并开始等待各AP 的响应</li>
</ol>
</li>
<li><ol start="2">
<li>执行事务<br>各个 AP 节点执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中，尽量把提交过程中所有消耗时间的操作和准备都提前完成确保后面 100%成功提交事务</li>
</ol>
</li>
<li><ol start="3">
<li>各个 AP 向 TM 反馈事务询问的响应<br>如果各个 AP 成功执行了事务操作，那么就反馈给 AP yes 的响应，表示事务可以执行；如果 AP 没有成功执行事务，就反馈给 TM no 的响应，表示事务不可以执行</li>
</ol>
</li>
</ul>
<p>上面这个阶段有点类似 TM 组织各个 AP 对一次事务操作的投票表态过程，因此2pc 协议的第一个阶段称为“投票阶段”，即各 AP 投票表名是否需要继续执行接下去的事务提交操作。</p>
<h5 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h5><p><img src="/分布式事务的解决方案/20191123033644482.png" alt></p>
<ul>
<li>事务提交<br>在这个阶段，TM 会根据各 AP 的反馈情况来决定最终是否可以进行事务提交操作，正常情况下包含两种可能假如 TM 从所有参与者获得的反馈都是 yes 响应，那么就会执行事务提交</li>
<li><ol>
<li>发送提交请求<br>TM 向所有 AP 节点发出 commit 请求</li>
</ol>
</li>
<li><ol start="2">
<li>事务提交<br>AP 接收到 Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源</li>
</ol>
</li>
<li><ol start="3">
<li>反馈事务提交结果<br>AP 在完成事务提交之后，向 TM 发送 Ack 消息</li>
</ol>
</li>
<li><ol start="4">
<li>完成事务<br>TM 接收到所有 AP 反馈的 ack 消息后，完成事务</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5></li>
</ul>
<pre><code>性能问题。从流程上我们可以看得出，其最大缺点就在于它的执行过程中间，节点都处于阻塞状态。各个操作数据库的节点此时都占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知进行全局提交，参与者进行本地事务提交后才会释放资源。这样的过程会比较漫长，对性能影响比较大。

协调者单点故障问题。事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，会导致参与者收不到提交或回滚的通知，从而导致参与者节点始终处于事务无法完成的中间状态。

丢失消息导致的数据不一致问题。在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就会导致节点间数据的不一致问题。
</code></pre><h4 id="三阶段提交（3PC）"><a href="#三阶段提交（3PC）" class="headerlink" title="三阶段提交（3PC）"></a>三阶段提交（3PC）</h4><p>三阶段提交又称3PC，其在两阶段提交的基础上增加了CanCommit阶段，并引入了超时机制。一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。</p>
<h3 id="分布式事务一致性"><a href="#分布式事务一致性" class="headerlink" title="分布式事务一致性"></a>分布式事务一致性</h3><h4 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h4><p>消息队列辅助、人工干预</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>多线程的实现原理</title>
    <url>/2019/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="JMM怎么解决原子性、可见性、有序性的问题？"><a href="#JMM怎么解决原子性、可见性、有序性的问题？" class="headerlink" title="JMM怎么解决原子性、可见性、有序性的问题？"></a>JMM怎么解决原子性、可见性、有序性的问题？</h2><p>在Java中提供了一系列和并发处理相关的关键字，比如<code>volatile</code>、<code>Synchronized</code>、<code>final</code>、<code>juc</code>等，这些就是Java内存<br>模型封装了底层的实现后提供给开发人员使用的关键字，在开发多线程代码的时候，我们可以直接使用<br><code>synchronized</code>等关键词来控制并发，使得我们不需要关心底层的编译器优化、缓存一致性的问题了，所以在Java内<br>存模型中，除了定义了一套规范，还提供了开放的指令在底层进行封装后，提供给开发人员使用。</p>
<h3 id="原子性保障"><a href="#原子性保障" class="headerlink" title="原子性保障"></a>原子性保障</h3><p>在java中提供了两个高级的字节码指令monitorenter和monitorexit，在Java中对应的<code>Synchronized</code>来保证代码块<br>内的操作是原子的</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变<br>量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。<br>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性<br><a id="more"></a></p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：<br><code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作。</p>
<h2 id="volatile如何解决可见性和有序性问题"><a href="#volatile如何解决可见性和有序性问题" class="headerlink" title="volatile如何解决可见性和有序性问题"></a>volatile如何解决可见性和有序性问题</h2><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>下载hsdis工具 ，<a href="https://sourceforge.net/projects/fcml/files/fcml-1.1.1/hsdis-1.1.1-win32-amd64.zip/download" target="_blank" rel="noopener">https://sourceforge.net/projects/fcml/files/fcml-1.1.1/hsdis-1.1.1-win32-amd64.zip/download</a><br>解压后存放到jre目录的server路径下<br><img src="https://i.loli.net/2019/01/31/5c52b9cc2abcb.png" alt><br>然后跑main函数，跑main函数之前，加入如下虚拟机参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-server</span><br><span class="line">-Xcomp</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+PrintAssembly</span><br><span class="line">-XX:CompileCommand=compileonly,*VolatileDemo.getInstance（替换成实际运行的代码）</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2019/01/31/5c52b9e1974ac.png" alt><br>运行main函数，在控制台可以看到<br><img src="https://i.loli.net/2019/01/31/5c52ba2858422.png" alt><br>volatile变量修饰的共享变量，<code>在进行写操作的时候会多出一个lock前缀的汇编指令</code>，<br>通过触发cpu的总线锁或者缓存锁，通过缓存一致性协议来解决可见性问题<br>对于声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，把这个变量所在的缓存行的数<br>据写回到系统内存，根据MESI缓存一致性协议，来保证多CPU下的各个高速缓存中的数据的一致性。</p>
<h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3>]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2019/11/30/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>入职的时候是公司在武汉刚刚成立研发中心，目标是接替北京公司的开发任务，在职期间一直负责公司大数据客户服务平台项目持续敏捷迭代开发和文档的编写，同时每次迭代对上线过程进行支撑<br>今年的主要任务是开发对BDCSC项目进行支撑的健康度项目和可视化配置中心的部署及接入并在10月底完成</p>
<h3 id="Object类有哪些方法，请列举你经常用到的"><a href="#Object类有哪些方法，请列举你经常用到的" class="headerlink" title="Object类有哪些方法，请列举你经常用到的"></a>Object类有哪些方法，请列举你经常用到的</h3><ul>
<li>toString:打印地址值，一般用于重新写方法打印具体值</li>
<li>equals：对比地址值，一般用于重写比较两个对象值是否相等</li>
<li>hashCode：计算对象的hash值，重写equals方法时必须重写hashCode方法以满足两个对象在equals为true时hash值也相同的条件，便于使用在hashmap等集合中</li>
<li>wait：释放锁对象，使当前线程等待，等待唤醒</li>
<li>notify/notifyAll 唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。</li>
<li>clone：快速构造一个与已有对象相同的副本，属于浅克隆，要实现深克隆需要引用对象也重写该方法或通过序列化的方式<h3 id="并发包Concurrent下有哪些你经常使用的类"><a href="#并发包Concurrent下有哪些你经常使用的类" class="headerlink" title="并发包Concurrent下有哪些你经常使用的类"></a>并发包Concurrent下有哪些你经常使用的类</h3><h4 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock 可重入锁"></a>ReentrantLock 可重入锁</h4>  内部维护了一个AQS同步队列，AQS 队列内部维护的是一个FIFO 的双向链表，每个链表的节点是由线程封装Node，当线程争抢锁失败后会封装成 Node 加入到 ASQ 队列中去；当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</li>
<li><p>获取锁<br>  调用Lock.lock 首先会通过CAS操作尝试替换state，替换成功说明抢占到锁，将当前线程设置为AQS的独占线程<br>  抢占失败调用 acquire(1)走锁竞争逻辑<br>  通过 tryAcquire 尝试获取独占锁，如果成功返回 true，失败返回 false，同时判断是否为拥有独占锁的线程，是则增加重入次数<br>  如果 tryAcquire 失败将当前线程封装成一个Node节点，判断当前AQS队列链表中的 tail 节点是否为空，如果不为空，则通过 cas 操作把当前线程的node 添加到 AQS 队列，如果为空或者 cas 失败，调用 enq 自旋地将节点添加到 AQS 队列，如果tail为null，初始化一个空Node并将head和tail都指向它。<br>  将Node添加到同步队列后会接着把 Node 作为参数传递给acquireQueued 方法，去竞争锁，首先获取当前节点的prv节点，入过prv==head节点，那么它有资格去争抢锁，调用tryAcquire抢占锁，抢占锁成功以后，把获得锁的节点设置为 head，并且移除原来的初始化head节点，如果获得锁失败，则根据 waitStatus 决定是否需要挂起线程，若为SIGNAL则阻塞，接下来会调用parkAndCheckInterrupt()阻塞当前线程并返回线程的中断标志，直到当前先被唤醒才从parkAndCheckInterrupt()中返回。最后，通过 cancelAcquire 取消获得锁的操作。</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>Condition 是一个多线程协调通信的工具类，可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒</p>
</li>
<li><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从 await()方法返回时，当前线程一定获取了Condition 相关联的锁<br><img src="/面试题/20191130054315839.png" alt></p>
<p>线程 awaitThread 先通过 lock.lock()方法获取锁成功后调用了 condition.await 方法进入等待队列，而另一个线程 signalThread 通过 lock.lock()方法获取锁成功后调用了 condition.signal 或者 signalAll 方法，使得线程awaitThread 能够有机会移入到同步队列中，当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取lock，从而使得线程 awaitThread 能够从 await 方法中退出执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列。</p>
</li>
<li><p>await()：当前线程调用await()方法，会使当前线程进入等待队列，同时线程状态变为等待状态，当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
</li>
<li>signal()：调用该方法将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。</li>
</ul>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>countdownlatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完毕再执行。从命名可以解读到 countdown 是倒数的意思，类似于我们倒计时的概念。</p>
<p>countdownlatch 提供了两个方法，一个是 countDown，一个是 await， countdownlatch 初始化的时候需要传入一个整数，在这个整数倒数到 0 之前，调用了 await 方法的程序都必须要等待，然后通过 countDown 来倒数。</p>
<h4 id="ConcurrentHashMap（jdk1-8）"><a href="#ConcurrentHashMap（jdk1-8）" class="headerlink" title="ConcurrentHashMap（jdk1.8）"></a>ConcurrentHashMap（jdk1.8）</h4><ul>
<li>数据结构：数组+单向链表 链表长度&gt;8转红黑树</li>
<li>初始化table：CAS的改变sizeCtl的值为-1，表示占位符，初始化成功后设置sizeCtl为加载因子</li>
<li>自旋尝试插入数据</li>
<li>tabAt：通过可见性的方法读取最新的值</li>
<li>casTabAt：原子更新，对key计算hash值后所在的数组位置为空则通过cas将数据插入当前位置</li>
<li>当前下标有元素，对当前下标的头节点加锁，不阻塞其他下标</li>
<li>addCount：计数，元素增加、扩容判断</li>
<li>尝试一次通过CAS操作设置元素个数，失败通过随机数将CounterCell数组中某个位置的值用CAS替换CounterCell的value值<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5></li>
<li>sizeCtl&lt;0说明已经有线程在进行扩容</li>
<li>标记正在扩容线程数：通过当前tab.length计算后得到一个扩容戳，左移16位，高16位代表扩容的标记，低16位代表扩容的线程数</li>
<li>transfer ：扩容（转移数据）：默认每个cpu执行16个大小的扩容，设置分工区间，每个线程处理完将标记的低16位-1</li>
<li>使用一个CounterCell数组将并发的请求分流到每个数组位置进行cas增加<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4>使用场景：限流<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4>当存在需要所有的子任务都完成时，才执行主任务，这个时候就可以选择使用 CyclicBarrier，可重复使用</li>
</ul>
<h3 id="说说对Threadlocal的理解"><a href="#说说对Threadlocal的理解" class="headerlink" title="说说对Threadlocal的理解"></a>说说对Threadlocal的理解</h3><p>ThreadLocal 用一种存储变量与线程绑定的方式，在每个线程中用自己的 ThreadLocalMap 安全隔离变量<br>每个线程拥有自己唯一的 ThreadLocalMap ，所以 ThreadLocalMap 是天然线程安全的。、<br>每个线程持有自己的 ThreadLocalMap，ThreadLocalMap 初始容量为16，在调用ThreadLocal 的 set 方法时，将以 ThreadLocal 为 Key 存储在 本线程的 ThreadLocalMap 里面，ThreadLocalMap 的 Value 为Object 类型，实际类型由 ThreadLocal 定义。</p>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>ThreadLocalMap 是ThreadLocal 内部的一个Map实现，然而它并没有实现任何集合的接口规范，因为它仅供内部使用，数据结构采用 数组 + 开放地址法，Entry 继承 WeakReference，是基于 ThreadLocal 这种特殊场景实现的 Map。<br>WeakReference如字面意思，弱引用， 当一个对象仅仅被weak reference（弱引用）指向, 而没有任何其他strong reference（强引用）指向的时候, 如果这时GC运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>大小必须是2的N次幂可以更好的服务于key的hash算法，数组的index更加分散</p>
<ul>
<li>key的hashcode<br>首先将key的hashcode值的高16位和低16位进行亦或运算</li>
<li>初始化<br>初始化一个默认大小为16的Node数组<br>将计算得到的hash值与Node数组容量-1进行与运算，得到一个数组的位置<br>初始化一个新的Node节点插入进该索引位置<br>如果当前位置有数据则加入到链表尾部，长度大于等于8则转为红黑树</li>
<li>扩容<br>将数组大小左移1位进行翻倍<br>重新计算hash值与新的数组大小-1进行与运算<br>如果是链表则拆分后判断数据扩容后存储在当前位置还是当前位置+扩容前大小的位置</li>
<li>记录put后的数组大小并判断是否要扩容</li>
</ul>
<h3 id="红黑树你了解多少，为什么要用红黑树，解决了哪些问题"><a href="#红黑树你了解多少，为什么要用红黑树，解决了哪些问题" class="headerlink" title="红黑树你了解多少，为什么要用红黑树，解决了哪些问题"></a>红黑树你了解多少，为什么要用红黑树，解决了哪些问题</h3><ul>
<li>红黑树：红黑是是一个平衡二叉树</li>
<li>根节点和每个叶子节点是黑色</li>
<li>如果一个节点是红色的，name它的两个子节点都是黑色</li>
<li>从任一节点到其每个叶子的所有简单路径，都包含相同数目的黑色节点</li>
<li>如果加入节点破坏了规则的话则进行左旋或右旋或重新着色</li>
<li>链表元素大于8个时插入成本较高，红黑树插入和删除效率比avl树高，查询效率比链表高<h3 id="类加载-双亲委派"><a href="#类加载-双亲委派" class="headerlink" title="类加载 双亲委派"></a>类加载 双亲委派</h3>加载一个class的时候会先加载启动类加载器和扩展类加载器<br>，防止jdk代码不被使用者篡改<br>可以破坏但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。<h3 id="谈谈你对sql性能调优的理解和开发中的使用"><a href="#谈谈你对sql性能调优的理解和开发中的使用" class="headerlink" title="谈谈你对sql性能调优的理解和开发中的使用"></a>谈谈你对sql性能调优的理解和开发中的使用</h3></li>
<li>索引列的数据长度能少则少。</li>
<li>索引一定不是越多越好，越全越好，一定是建合适的。</li>
<li>匹配列前缀可用到索引 like 9999%（列的离散型高的情况下），like %9999%、like %9999用不到索引；</li>
<li>Where 条件中 not in 和 &lt;&gt;操作无法使用索引；</li>
<li>匹配范围值，order by 也可用到索引；</li>
<li>多用指定列查询，只返回自己想到的数据列，少用select * ；</li>
<li>联合索引中如果不是按照索引·最左列开始查找，无法使用索引；</li>
<li>联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引；</li>
<li>联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引；</li>
<li>在创建索引时尽量使用不能为null的列<h3 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h3>问题：<br>  1：短时间高并发，负载压力大<br>  2：读多写少<br>  3：竞争资源有限，不能多卖、少卖</li>
<li>倒计时开卖</li>
<li>限制用户购买的数量</li>
<li>尽量将请求过滤在上游</li>
<li>尽可能利用缓存存储商品和库存信息</li>
<li>分布式限流</li>
<li>异步化处理订单和库存，前端轮训成功或失败</li>
<li>下单扣库存，超时收回库存,使用乐观锁防止超卖</li>
<li>保持数据库和缓存的一致性</li>
<li>查询商品详情-&gt;点击购买-&gt;校验库存-&gt;扣除库存，创建订单-&gt;支付</li>
<li>后台操作添加库存信息至缓存</li>
<li><h3 id="模块间通讯"><a href="#模块间通讯" class="headerlink" title="模块间通讯"></a>模块间通讯</h3></li>
<li>HTTP方式</li>
<li>RPC协议</li>
<li>负载均衡问题、超时问题、<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4>初始化：Bean被创建的时候回调InitializingBean<br>销毁：Bean被销毁的时候回调DisposableBean<br>可以通过init-Method和destroy-Method监控Bean的创建和销毁，@PostConstruct 和@PreDestroy 注解方式<h4 id="Spring-Bean-作用域之间的区别？"><a href="#Spring-Bean-作用域之间的区别？" class="headerlink" title="Spring Bean 作用域之间的区别？"></a>Spring Bean 作用域之间的区别？</h4>1.singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean 的实例，单例的模式由 bean factory 自身来维护。<br>2.prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。<br>3.request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。<br>4.Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。<br>5.global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。<h4 id="Spring-框架中的单例-Beans-是线程安全的么？"><a href="#Spring-框架中的单例-Beans-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Beans 是线程安全的么？"></a>Spring 框架中的单例 Beans 是线程安全的么？</h4>Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如 Serview 类和 DAO类)，所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状态的话（比如View Model 对象），就需要自行保证线程安全。  最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。<h4 id="Spring是怎样处理循环依赖问题的"><a href="#Spring是怎样处理循环依赖问题的" class="headerlink" title="Spring是怎样处理循环依赖问题的"></a>Spring是怎样处理循环依赖问题的</h4>通过三级缓存来处理</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>并发编程之ReentrantLock可重入锁</title>
    <url>/2019/05/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BReentrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
    <content><![CDATA[<p>ReentrantLock是并发包<code>Java.util.concurrent</code>里的一个基于Lock接口实现的可重入锁。</p>
<h1 id="J-U-C-简介"><a href="#J-U-C-简介" class="headerlink" title="J.U.C 简介"></a>J.U.C 简介</h1><p><code>Java.util.concurrent</code> 是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的组件。比如线程池、阻塞队列、计时器、同步器、并发集合等等。并发包的作者是大名鼎鼎的 Doug Lea。</p>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>在 Lock 接口出现之前，Java 中的应用程序对于多线程的并发安全处理只能基于synchronized 关键字来解决。但是 synchronized 在有些场景中会存在一些短板，也就是它并不适合于所有的并发场景。但是在 Java5 以后，Lock 的出现可以解决synchronized 在某些场景中的短板，它比 synchronized 更加灵活。</p>
<h2 id="Lock接口提供的synchronized关键字不具备的主要特性"><a href="#Lock接口提供的synchronized关键字不具备的主要特性" class="headerlink" title="Lock接口提供的synchronized关键字不具备的主要特性"></a>Lock接口提供的synchronized关键字不具备的主要特性</h2><p><code>尝试非阻塞的获得锁</code>：当线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。<br><code>能被中断地获取锁</code>：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。<br><code>超时获取锁</code>：在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回。</p>
<h2 id="Lock的实现"><a href="#Lock的实现" class="headerlink" title="Lock的实现"></a>Lock的实现</h2><p>Lock 本质上是一个接口，它定义了释放锁和获得锁的抽象方法，定义成接口就意味着它定义了锁的一个标准规范，也同时意味着锁的不同实现。实现 Lock 接口的类有很多，以下为几个常见的锁实现ReentrantLock：表示重入锁，它是唯一一个实现了 Lock 接口的类。重入锁指的是线程在获得锁之后，再次获取该锁不需要阻塞，而是直接关联一次计数器增加重入次数</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><code>重入读写锁</code>，它实现了 ReadWriteLock 接口，在这个类中维护了两个锁，一个是 ReadLock，一个是 WriteLock，他们都分别实现了 Lock接口。读写锁是一种适合读多写少的场景下解决线程安全问题的工具，基本原则是： 读和读不互斥、读和写互斥、写和写互斥。也就是说涉及到影响数据变化的操作都会存在互斥。</p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>stampedLock</code> 是 JDK8 引入的新的锁机制，可以简单认为是读写锁的一个改进版本，读写锁虽然通过分离读和写的功能使得读和读之间可以完全并发，但是读和写是有冲突的，如果大量的读线程存在，可能会引起写线程的饥饿。</p>
<h3 id="stampedLock"><a href="#stampedLock" class="headerlink" title="stampedLock"></a>stampedLock</h3><p><code>stampedLock</code>是一种乐观的读策略，使得乐观锁完全不会阻塞写线程<br><a id="more"></a></p>
<h2 id="Lock的类关系图"><a href="#Lock的类关系图" class="headerlink" title="Lock的类关系图"></a>Lock的类关系图</h2><p>Lock 有很多的锁的实现，但是直观的实现是 ReentrantLock 重入锁<br><img src="https://i.loli.net/2019/05/22/5ce508ae4243257738.png" alt="Lock的类关系图"><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="comment">// 如果锁可用就获得锁，如果锁不可用就阻塞</span></span></span><br><span class="line"><span class="function">直到锁释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="comment">// 和lock()方法相似, 但阻塞的线程可中断,抛出java.lang.InterruptedException 异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> <span class="comment">// 非阻塞获取锁;尝试获取锁，如果成功</span></span></span><br><span class="line"><span class="function">返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>  <span class="title">tryLock</span><span class="params">(longtimeout, TimeUnit timeUnit)</span></span></span><br><span class="line"><span class="function"><span class="comment">//带有超时时间的获取锁方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="comment">// 释放锁</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="ReentrantLockk可重入锁"><a href="#ReentrantLockk可重入锁" class="headerlink" title="ReentrantLockk可重入锁"></a>ReentrantLockk可重入锁</h1><p>可重入锁，表示支持重新进入的锁，也就是说，如果当前线程 t1 通过调用 lock 方法获取了锁之后，再次调用 lock，是不会再阻塞去获取锁的，直接增加重试次数就行了。synchronized 和 ReentrantLock 都是可重入锁。</p>
<h3 id="重入锁的设计目的"><a href="#重入锁的设计目的" class="headerlink" title="重入锁的设计目的"></a>重入锁的设计目的</h3><p>比如调用 demo 方法获得了当前的对象锁，然后在这个方法中再去调用demo2，demo2 中的存在同一个实例锁，这个时候当前线程会因为无法获得demo2 的对象锁而阻塞，就会产生死锁。重入锁的设计目的是避免线程的死锁。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"begin:demo"</span>);</span><br><span class="line">        demo2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"begin:demo1"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantDemo rd=<span class="keyword">new</span> ReentrantDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(rd::demo).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock的使用案例"><a href="#ReentrantLock的使用案例" class="headerlink" title="ReentrantLock的使用案例"></a>ReentrantLock的使用案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;AtomicDemo.inc();&#125;).start();;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"result:"</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：result:1000</p>
<h2 id="ReentrantLock-的实现原理"><a href="#ReentrantLock-的实现原理" class="headerlink" title="ReentrantLock 的实现原理"></a>ReentrantLock 的实现原理</h2><p>锁的基本原理是，基于将多线程并行任务通过某一种机制实现线程的串行执行，从而达到线程安全性的目的。在 synchronized 中使用了<code>偏向锁、轻量级锁、乐观锁</code>。基于乐观锁以及自旋锁来优化了 synchronized 的加锁开销，同时在重量级锁阶段，通过线程的阻塞以及唤醒来达到线程竞争和同步的目的。那么在 ReentrantLock 中，也一定会存在这样的需要去解决的问题。就是在多线程竞争重入锁时，竞争失败的线程是如何实现阻塞以及被唤醒的？</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>在 Lock 中，用到了一个同步队列 AQS，全称 <code>AbstractQueuedSynchronizer</code>，它是一个同步工具也是 Lock 用来实现线程同步的核心组件。如果搞懂了AQS，那么J.U.C中绝大部分的工具都能轻松掌握。</p>
<h3 id="AQS的两种功能"><a href="#AQS的两种功能" class="headerlink" title="AQS的两种功能"></a>AQS的两种功能</h3><p>从使用层面来说，AQS的功能分为两种：独占和共享<br><code>独占锁</code>：每次只能有一个线程持有锁，比如前面给大家演示的 ReentrantLock 就是<br>以独占方式实现的互斥锁<br><code>共享锁</code>：允许多个线程同时获取锁，并发访问共享资源，比如<code>ReentrantReadWriteLock</code></p>
<h3 id="AQS的内部实现"><a href="#AQS的内部实现" class="headerlink" title="AQS的内部实现"></a>AQS的内部实现</h3><p>AQS 队列内部维护的是一个<code>FIFO 的双向链表</code>，这种结构的特点是<code>每个数据结构都有两个指针</code>，分别<code>指向直接的后继节点和直接前驱节点</code>。所以双向链表可以从任意一个节点开始很方便的访问前驱和后继。每个Node其实是由线程封装，当线程争抢锁失败后会封装成 Node 加入到 ASQ 队列中去；当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。<br><img src="https://i.loli.net/2019/05/22/5ce50e7c681cb83068.png" alt></p>
<h3 id="Node的组成"><a href="#Node的组成" class="headerlink" title="Node的组成"></a>Node的组成</h3><p><img src="https://i.loli.net/2019/05/24/5ce762908da7a10150.png" alt></p>
<h3 id="释放锁以及添加线程对于队列的变化"><a href="#释放锁以及添加线程对于队列的变化" class="headerlink" title="释放锁以及添加线程对于队列的变化"></a>释放锁以及添加线程对于队列的变化</h3><p>当出现锁竞争以及释放锁的时候，AQS 同步队列中的节点会发生变化</p>
<h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p><img src="https://i.loli.net/2019/05/24/5ce76359f0beb47498.png" alt><br>涉及到两个变化</p>
<ol>
<li>新的线程封装成 Node 节点追加到同步队列中，设置 prev 节点以及修改当前节<br>点的前置节点的 next 节点指向自己</li>
<li>通过 CAS将tail 重新指向新的尾部节点<br>head 节点表示获取锁成功的节点，当头结点在释放同步状态时，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头结点，节点的变化过程如下<br><img src="https://i.loli.net/2019/05/24/5ce7635a0a1a551657.png" alt><br>这个过程也是涉及到两个变化</li>
<li>修改 head 节点指向下一个获得锁的节点</li>
<li>新的获得锁的节点，将 prev 的指针指向 null<br>设置 head 节点不需要用 CAS，原因是设置 head 节点是由获得锁的线程来完成的，而同步锁只能由一个线程获得，所以不需要 CAS 保证，只需要把 head 节点设置为原首节点的后继节点，并且断开原 head 节点的 next 引用即可。<h2 id="ReentrantLock的源码分析"><a href="#ReentrantLock的源码分析" class="headerlink" title="ReentrantLock的源码分析"></a>ReentrantLock的源码分析</h2>ReentrantLock的时序图<br>调用ReentrantLock中的lock()方法，源码的调用过程使用时序图来展现。<br><img src="https://i.loli.net/2019/06/06/5cf8b08a120af52795.png" alt><br>ReentrantLock.lock()<br>这个是 reentrantLock 获取锁的入口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>sync 实际上是一个抽象的静态内部类，它继承了 AQS 来实现重入锁的逻辑， AQS 是一个同步队列，它能够实现线程的阻塞以及唤醒，但它并不具备业务功能，所以在不同的同步场景中，会继承 AQS 来实现对应场景的功能<br>Sync 有两个具体的实现类，分别是：<br>NofairSync：表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁<br>FailSync: 表示所有线程严格按照 FIFO 来获取锁<br>以非公平锁为例，来看看 lock 中的实现<br>1、非公平锁和公平锁最大的区别在于，在非公平锁中我抢占锁的逻辑是，不管有没有线程排队，我先上来 cas 去抢占一下<br>2、 CAS 成功，就表示成功获得了锁<br>3、CAS 失败，调用 acquire(1)走锁竞争逻辑<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CAS-的实现原理"><a href="#CAS-的实现原理" class="headerlink" title="CAS 的实现原理"></a>CAS 的实现原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(intexpect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="comment">// See below for intrinsics setup to support</span></span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>,</span><br><span class="line">        stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 cas 乐观锁的方式来做比较并替换，这段代码的意思是，如果当前内存中的state 的值和预期值 expect 相等，则替换为 update。更新成功返回 true，否则返回 false.这个操作是原子的，不会出现线程安全问题，这里面涉及到Unsafe这个类的操作，以及涉及到 state 这个属性的意义。</p>
<p>state 是 AQS 中的一个属性，它在不同的实现中所表达的含义不一样，对于重入锁的实现来说，表示一个同步状态。它有两个含义的表示</p>
<ol>
<li>当 state=0 时，表示无锁状态</li>
<li>当 state&gt;0 时，表示已经有线程获得了锁，也就是 state=1，但是因为ReentrantLock 允许重入，所以同一个线程多次获得同步锁的时候，state 会递增，比如重入 5 次，那么 state=5。 而在释放锁的时候，同样需要释放 5 次直到 state=0其他线程才有资格获得锁</li>
</ol>
<h4 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h4><p>Unsafe 类是在 sun.misc 包下，不属于 Java 标准。但是很多 Java 的基础类库，包括一些被广泛使用的高性能开发库都是基于 Unsafe 类开发的，比如 Netty、Hadoop、Kafka 等；Unsafe 可认为是 Java 中留下的后门，提供了一些低层次操作，如直接内存访问、线程的挂起和恢复、CAS、线程同步、内存屏障而 CAS 就是 Unsafe 类中提供的一个原子操作，第一个参数为需要改变的对象，第二个为偏移量(即之前求出来的 headOffset 的值)，第三个参数为期待的值，第四个为更新后的值整个方法的作用是如果当前时刻的值等于预期值 var4 相等，则更新为新的期望值 var5，如果更新成功，则返回 true，否则返回 false；</p>
<h4 id="stateOffset"><a href="#stateOffset" class="headerlink" title="stateOffset"></a>stateOffset</h4><p>一个 Java 对象可以看成是一段内存，每个字段都得按照一定的顺序放在这段内存里，通过这个方法可以准确地告诉你某个字段相对于对象的起始内存地址的字节偏移。用于在后面的 compareAndSwapInt 中，去根据偏移量找到对象在内存中的具体位置所以 stateOffset 表示 state 这个字段在 AQS 类的内存中相对于该类首地址的偏移量。</p>
<h4 id="compareAndSwapInt"><a href="#compareAndSwapInt" class="headerlink" title="compareAndSwapInt"></a>compareAndSwapInt</h4><p>在 unsafe.cpp 文件中，可以找到 compareAndSwarpInt 的实现<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset,jint e, jint x))</span><br><span class="line">UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">oop p = JNIHandles::resolve(obj); <span class="comment">//将 Java 对象解析成 JVM 的 oop（普通对象指针）,</span></span><br><span class="line">jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); <span class="comment">//根据对象 p 和地址偏移量找到地址</span></span><br><span class="line"><span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e; <span class="comment">//基于 cas 比较并替换， x 表示需要更新的值，addr 表示 state</span></span><br><span class="line">在内存中的地址，e 表示预期值</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure></p>
<h3 id="AQS-accquire"><a href="#AQS-accquire" class="headerlink" title="AQS.accquire"></a>AQS.accquire</h3><p>acquire 是 AQS 中的方法，如果 CAS 操作未能成功，说明 state 已经不为 0，此时继续 acquire(1)操作<br>这个方法的主要逻辑是</p>
<ol>
<li>通过 tryAcquire 尝试获取独占锁，如果成功返回 true，失败返回 false</li>
<li>如果 tryAcquire 失败，则会通过 addWaiter 方法将当前线程封装成 Node 添加到 AQS 队列尾部</li>
<li>acquireQueued，将 Node 作为参数，通过自旋去尝试获取锁。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="ReentrantLock-nofairTryAcquire"><a href="#ReentrantLock-nofairTryAcquire" class="headerlink" title="ReentrantLock.nofairTryAcquire"></a>ReentrantLock.nofairTryAcquire</h3><ol>
<li>获取当前线程，判断当前的锁的状态</li>
<li>如果 state=0 表示当前是无锁状态，通过 cas 更新 state 状态的值</li>
<li>当前线程是属于重入，则增加重入次数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//获取当前执</span></span><br><span class="line">  行的线程</span><br><span class="line">  <span class="keyword">int</span> c = getState();<span class="comment">//获得 state 的值</span></span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//表示无锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//cas 替换 state 的</span></span><br><span class="line">      值，cas 成功表示获取锁成功</span><br><span class="line">      setExclusiveOwnerThread(current);<span class="comment">//保存当前获得锁的线</span></span><br><span class="line">      程,下次再来的时候不要再尝试竞争锁</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//如果同一</span></span><br><span class="line">    个线程来获得锁，直接增加重入次数</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="AQS-addWaiter"><a href="#AQS-addWaiter" class="headerlink" title="AQS.addWaiter"></a>AQS.addWaiter</h3><p>当 tryAcquire 方法获取锁失败以后，则会先调用 addWaiter 将当前线程封装成Node.入参 mode 表示当前节点的状态，传递的参数是 Node.EXCLUSIVE，表示独占状态。意味着重入锁用到了 AQS 的独占锁功能</p>
<ol>
<li>将当前线程封装成 Node</li>
<li>当前链表中的 tail 节点是否为空，如果不为空，则通过 cas 操作把当前线程的node添加到AQS队列并设为tail节点</li>
<li>如果为空或者 cas 失败，调用 enq 将节点添加到 AQS 队列<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);<span class="comment">//把当前线程封装为 Node</span></span><br><span class="line">  Node pred = tail; <span class="comment">//tail 是 AQS 中表示同比队列队尾的属性，默认是 null</span></span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;<span class="comment">//tail 不为空的情况下，说明队列中存在节点</span></span><br><span class="line">    node.prev = pred;<span class="comment">//把当前线程的 Node 的 prev 指向 tail</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//通过 cas 把 node加入到 AQS 队列，也就是设置为 tail</span></span><br><span class="line">      pred.next = node;<span class="comment">//设置成功以后，把原 tail 节点的 next指向当前 node</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  enq(node);<span class="comment">//tail=null,把 node 添加到同步队列</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>enq 就是通过自旋操作把当前节点加入到队列中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">// 自旋，三个线程抢占至少自旋三次</span></span><br><span class="line">      Node t = tail;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">          tail = head;  <span class="comment">//初始化一个Node赋值给head和tail</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.prev = t;<span class="comment">//将tail节点设置为当前Node的prev</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="comment">//将当前Node设置为tail</span></span><br><span class="line">          t.next = node;<span class="comment">//将原tail节点的next设置为当前Node</span></span><br><span class="line">          <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h4><p>假设 3 个线程来争抢锁，那么截止到 enq 方法运行结束之后，或者调用 addwaiter方法结束后，AQS 中的链表结构图<br><img src="https://i.loli.net/2019/06/13/5d01fcc46592872966.png" alt></p>
<h3 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS.acquireQueued"></a>AQS.acquireQueued</h3><p>通过 addWaiter 方法把线程添加到链表后，会接着把 Node 作为参数传递给<br>acquireQueued 方法，去竞争锁</p>
<ol>
<li>获取当前节点的 prev 节点</li>
<li>如果 prev 节点为 head 节点，那么它就有资格去争抢锁，调用 tryAcquire 抢占锁</li>
<li>抢占锁成功以后，把获得锁的节点设置为 head，并且移除原来的初始化 head节点 </li>
<li>如果获得锁失败，则根据 waitStatus 决定是否需要挂起线程</li>
<li>最后，通过 cancelAcquire 取消获得锁的操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">        arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取当前节点的 prev 节点</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//如果是 head 节点，说明有资格去争抢锁</span></span><br><span class="line">        setHead(node); <span class="comment">//获取锁成功，也就是ThreadA 已经释放了锁，然后设置 head 为 ThreadB 获得执行权限</span></span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// 把原 head 节点从链表中移除</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//ThreadA 可能还没释放锁，使得 ThreadB 在执行 tryAcquire 时会返回 false</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p,node) &amp;&amp;</span><br><span class="line">              parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>; <span class="comment">//并且返回当前线程在等待过程中有没有中断过。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h4><p>如果 ThreadA 的锁还没有释放的情况下，ThreadB 和 ThreadC 来争抢锁肯定是会失败，那么失败以后会调用 shouldParkAfterFailedAcquire 方法Node 有 5 中状态，分别是：CANCELLED（1），SIGNAL（-1）、CONDITION（-2）、PROPAGATE(-3)、默认状态(0)<br><code>CANCELLED</code>: 在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该 Node 的结点, 其结点的 waitStatus <code>为CANCELLED</code>，即结束状态，进入该状态后的结点将不会再变化SIGNAL: 只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程<br><code>CONDITION</code>： 和 Condition 有关系<br><code>PROPAGATE</code>：共享模式下，PROPAGATE 状态的线程处于可运行状态<br><code>0</code>:初始状态<br>这个方法的主要作用是，通过 Node 的状态来判断，ThreadA 竞争锁失败以后是否应该被挂起。</p>
<ol>
<li>如果 ThreadA 的 pred 节点状态为 SIGNAL，那就表示可以放心挂起当前线程</li>
<li>通过循环扫描链表把 CANCELLED 状态的节点移除</li>
<li>修改 pred 节点的状态为 SIGNAL,返回 false.<br>返回 false 时，也就是不需要挂起，返回 true，则需要调用 parkAndCheckInterrupt挂起当前线程<figure class="highlight java"><figcaption><span>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//前置节点的</span></span><br><span class="line">    waitStatus</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//如果前置节点为 SIGNAL，意味着只需要等待其他前置节点的线程被释放，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回 true，意味着可以直接放心的挂起了</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//ws 大于 0，意味着 prev 节点取消了排队，直接移除这个节点就行</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"><span class="comment">//相当于: pred=pred.prev;</span></span><br><span class="line">        node.prev=pred;</span><br><span class="line">      &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>); <span class="comment">//这里采用循环，从双向列表中移除 CANCELLED 的节点</span></span><br><span class="line">      pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//利用 cas 设置 prev 节点的状态为 SIGNAL(-1)</span></span><br><span class="line">      compareAndSetWaitStatus(pred, ws,</span><br><span class="line">              Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h4><p>使用 LockSupport.park 挂起当前线程编程 WATING 状态Thread.interrupted，返回当前线程是否被其他线程触发过中断请求，也就是<br>thread.interrupt(); 如果有触发过中断请求，那么这个方法会返回当前的中断标识true，并且对中断标识进行复位标识已经响应过了中断请求。如果返回 true，意味着在 acquire 方法中会执行 selfInterrupt()。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>selfInterrupt： 标识如果当前线程在 acquireQueued 中被中断过，则需要产生一<br>个中断请求，原因是线程在调用 acquireQueued 方法的时候是不会响应中断请求<br>的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图解分析<br>通过 acquireQueued 方法来竞争锁，如果 ThreadA 还在执行中没有释放锁的话，意味着 ThreadB 和 ThreadC 只能挂起了。<br><img src="https://i.loli.net/2019/06/18/5d08a3cbb0d2f82086.png" alt></p>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>LockSupport类是Java6引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了 Unsafe 类里的函数，归结到 Unsafe 里，只有两个函数unpark 函数为线程提供“许可(permit)”，线程调用 park 函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。permit 相当于 0/1 的开关，默认是 0，调用一次 unpark 就加 1 变成了 1.调用一次park 会消费 permit，又会变成 0。 如果再调用一次 park 会阻塞，因为 permit 已经是 0 了。直到 permit 变成 1.这时调用 unpark 会把 permit 设置为 1.每个线程都有一个相关的 permit，permit 最多只有一个，重复调用 unpark 不会累积。</p>
<h3 id="锁的释放流程"><a href="#锁的释放流程" class="headerlink" title="锁的释放流程"></a>锁的释放流程</h3><p>ReentrantLock.unlock<br>在 unlock 中，会调用 release 方法来释放锁<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">//释放锁成功</span></span><br><span class="line">    Node h = head; <span class="comment">//得到 aqs 中 head 节点</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)<span class="comment">//如果 head 节点不为空并且状态！=0.调用 unparkSuccessor(h)唤醒后续节点</span></span><br><span class="line">    unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReentrantLock.tryRelease<br>这个方法可以认为是一个设置锁状态的操作，通过将 state 状态减掉传入的参数值（参数是 1），如果结果状态为 0，就将排它锁的 Owner 设置为 null，以使得其它的线程有机会进行执行。在排它锁中，加锁的时候状态会增加 1（当然可以自己修改这个值），在解锁的时候减掉 1，同一个锁，在可以重入后，可能会被叠加为 2、3、4 这些值，只有 unlock()的次数与 lock()的次数对应才会将 Owner 线程设置为空，而且也只有这种情况下才会返回 true。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread() !=</span><br><span class="line">              getExclusiveOwnerThread())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          free = <span class="keyword">true</span>;</span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      setState(c);</span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><pre><code>调用Lock.lock 首先会通过CAS操作尝试替换state，替换成功说明抢占到锁，将当前线程设置为AQS的独占线程
CAS替换失败会调用acquire(1)方法中的tryAcquire(1)方法尝试抢占锁，如果state=0，CAS尝试获取锁成功返回true，失败返回false，state不等于0判断独占线程是否是当前线程，是则增加重入次数，不是返回false；
尝试获取锁失败会调用acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，首先将当前线程封装成一个Node节点，如果当前AQS队列链表中的 tail 节点是否为空，如果不为空，则通过 cas 操作把当前线程的node 添加到 AQS 队列，如果为空或者 cas 失败，调用 enq 自旋地将节点添加到 AQS 队列，如果tail为null，初始化一个空Node并将head和tail都指向它。
将Node添加到同步队列后会接着把 Node 作为参数传递给acquireQueued 方法，去竞争锁，首先获取当前节点的prv节点，入过prv==head节点，那么它有资格去争抢锁，调用tryAcquire抢占锁，抢占锁成功以后，把获得锁的节点设置为 head，并且移除原来的初始化head节点，如果获得锁失败，则根据 waitStatus 决定是否需要挂起线程，若为SIGNAL则阻塞，接下来会调用parkAndCheckInterrupt()阻塞当前线程，直到当前先被唤醒才从parkAndCheckInterrupt()中返回。最后，通过 cancelAcquire 取消获得锁的操作。

lock.lock():获取锁compareAndSetState(0, 1)；true获得锁成功，false acquire(1)
acquire()：tryAcquire：尝试获取锁；addWaiter：将当前线程封装成Node；acquireQueued：竞争锁
tryAcquire()：尝试竞争锁，成功返回true，失败返回false，如果同一个线程来获得锁，直接增加重入次数
addWaiter()：将当前线程封装成独占状态Node、当前链表中的 tail 节点是否为空，如果不为空，则通过 cas 操作把当前线程的node 添加到 AQS 队列、如果为空或者 cas 失败，调用 enq 将节点添加到 AQS 队列
enq()：通过自旋操作把当前节点加入到队列中
acquireQueued():如果当前节点的prv为head，竞争锁、获得锁成功移除原head，设置当前为head、失败挂起
</code></pre>]]></content>
  </entry>
  <entry>
    <title>设计模式中的工厂模式</title>
    <url>/2019/01/30/DesignPattern/factory/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p><code>工厂模式</code> 是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。著名的Jive论坛 ,就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如<code>A a=new A()</code> 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>应用场景：又叫做<code>静态工厂方法（StaticFactory Method）模式</code>，但不属于 23 种设计模式之一。</p>
<p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。<br>Spring 中的 BeanFactory 就是简单工厂模式的体现，根据传入一个唯一的标识来获得 Bean 对象，但<br>是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。<br><a id="more"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>首先定了一个产品的标准</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义3种产品,实现 <code>Phone</code>接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Huawei</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"华为"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小米"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义一个简单工厂<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"苹果"</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"华为"</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Huawei();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"华为"</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> XiaoMi();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"不能生产您所需的产品"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个new的过程实际上一个比较复杂的过程</span></span><br><span class="line">        <span class="comment">//     Apple apple = new Apple();</span></span><br><span class="line">        <span class="comment">//    System.out.println(apple.getName());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//小作坊式的生产模式</span></span><br><span class="line">        <span class="comment">//用户本身不再关心生产的过程，而只需要关心这个结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//华为、苹果、小米的配件是不一样的</span></span><br><span class="line">        SimpleFactory factory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        <span class="comment">//把用户的需求告诉工厂</span></span><br><span class="line">        <span class="comment">//创建产品的过程隐藏了，对于用户而且完全不清楚是怎么产生的</span></span><br><span class="line">        Phone phone = factory.getPhone(<span class="string">"苹果"</span>);</span><br><span class="line">        phone.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="工厂列表模式"><a href="#工厂列表模式" class="headerlink" title="工厂列表模式"></a>工厂列表模式</h2><p>工厂列表模式</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
